{"version":3,"sources":["node_modules/browserify/node_modules/browser-pack/_prelude.js","node_modules/clusterfck/lib/clusterfck.js","compass.js","node_modules/clusterfck/lib/distance.js","node_modules/clusterfck/lib/hcluster.js","node_modules/clusterfck/lib/kmeans.js","src/cluster/cluster.js","src/cluster/clusterconsts.js","src/cluster/distance.js","src/consts.js","src/cp","src/gen/aggregates.js","src/gen/encodings.js","src/gen/encs.js","src/gen/gen.js","src/gen/marktypes.js","src/gen/projections.js","src/globals.js","src/rank/rank.js","src/rank/rankEncodings.js","src/util.js","../vega-lite/src/globals.js"],"names":["f","exports","module","define","amd","g","window","global","self","this","cp","e","t","n","r","s","o","u","a","require","i","Error","code","l","call","length",1,"hcluster","Kmeans","kmeans","./hcluster","./kmeans",2,"euclidean","v1","v2","total","Math","pow","sqrt","manhattan","abs","max",3,"distances","HierarchicalClustering","distance","linkage","threshold","undefined","Infinity","prototype","cluster","items","snapshotPeriod","snapshotCb","clusters","dists","mins","index","value","key","size","j","dist","merged","mergeClosest","forEach","minKey","min","c1","c2","left","right","splice","ci","key1","key2","snapshot","snapshotCallback","./distance",4,"KMeans","centroids","randomCentroids","points","k","slice","sort","round","random","classify","point","ceil","assignment","Array","iterations","movement","assigned","push","centroid","newCentroid","sum","toJSON","JSON","stringify","fromJSON","json","parse","vectors",5,"encodings","opt","table","clusterTrees","clusterfck","e1","e2","s1","vl","Encoding","shorthand","s2","consts","CLUSTER_THRESHOLD","map","tree","util","traverse","encoding1","encoding2","_info","score","filter","cluster1","cluster2","../util","./clusterconsts",6,"reduceTupleToTable","x","b","d","c","SWAPPABLE","DIST_MISSING","DIST_BY_ENCTYPE","reduce",7,"len","colencs","getEncTypeByColumnName","shorthands","diff","sj","si","get","colenc1","colenc2","cols","union","keys","col","encType","isStack1","isStack","isStack2","encoding","color","name","_colenc","enc","duplicate","marktype",8,"gen","rank","projections","type","properties","omitDotPlot","default","description","maxCardinalityForAutoAddOrdinal","alwaysAddHistogram","aggregates","config","data","tableTypes","enum","genDimQ","minCardinalityForBin","omitMeasureOnly","omitDimensionOnly","addCountForDimensionOnly","aggrList","timeUnitList","consistentAutoQ","marktypeList","encodingTypeList","maxGoodCardinalityForFacets","maxCardinalityForFacets","maxGoodCardinalityForColor","maxCardinalityForColor","maxCardinalityForShape","omitTranpose","omitDotPlotWithExtraEncoding","omitMultipleRetinalEncodings","omitNonTextAggrWithAllDimsOnFacets","omitOneDimensionCount","omitSizeOnBar","omitStackedAverage","alwaysGenerateTableAsHeatmap",9,"auto","./cluster/cluster","./consts","./gen/gen","./rank/rank","./util",10,"genAggregates","output","fields","stats","emit","fieldSet","encDef","checkAndPush","hasMeasure","hasDimension","hasRaw","tf","isDimension","aggregate","count","pop","assignAggrQ","hasAggr","autoMode","canHaveAggr","cantHaveAggr","assignField","assignBinQ","bin","assignQ","_aggregate","_raw","_bin","AUTO","isin","hasNorO","highCardinality","cardinality","isAuto","genBin","genCast","assignTimeUnitT","timeUnit","assignT","_timeUnit","Q","T","O","N","schema","extend","any","isTypes","../consts",11,"genEncodingsFromFields","nested","encs","genEncs","dict","genEncodingsFromEncs","list","getMarktypes","markType","finalTouch","text","et","field","isMeasure","isCount","stat","stdev","mean","scale","zero","../rank/rank","./encs","./marktypes",12,"retinalEncRules","shape","colorRules","shapeRules","dimMeaTransposeRule","y","generalRules","genMarkTypes","satisfyRules","TEXT","geo","arc","row","isAggrWithAllDimOnFacets","isDimX","isDimY","isAggregate","tmpEnc","isDim","rules","dimension","measure","multiple","detail","hasOtherO","ROW","COL","../globals",13,"marktypes","charts","cfg","flat","getOpt","fieldSets","genAggr","level","nestedReduce","nestedMap","./aggregates","./encodings","./projections",14,"vlmarktypes","facetRule","facetsRule","pointRule","xIsDim","yIsDim","tickRule","isOrdinalScale","barRule","aggEitherXorY","eitherXorYisDimOrNull","lineRule","areaRule","textRule","marksRule","rule","bar","line","area","tick","mark","compiler","marks","reqs","requiredEncoding","support","supportedEncoding",15,"selected","fieldsToAdd","hasSelectedDimension","hasSelectedMeasure","indices","compareFieldsToAdd","setsToAdd","chooseKorLess","setToAdd","concat","typeIsMeasureScore","projection","join",16,"CHART_TYPES","TABLE","BAR","PLOT","LINE","AREA","MAP","HISTOGRAM","ANY_DATA_TYPES","vega-lite/src/globals",17,"./rankEncodings",18,"rankEncodings","features","encTypes","encodingMappingByField","mappings","reasons","m","assign","scores","role","reason","apply","UNUSED_POSITION","MARK_SCORE","p","circle","square","D","M","BAD","TERRIBLE","minor","pos","Y_T","facet_text","facet_good","facet_ok","facet_bad","color_good","color_ok","color_bad","color_stack","bad","terrible","dimensionScore","X","Y","COLOR","hasOrder","isStacked","SHAPE","DETAIL","measureScore","SIZE",19,"isArray","obj","toString","sp","v","nonEmpty","grp","node","arr","Object","create","DEFAULT_OPT","powerset","ps","subset","sub","chooseK","kArray","cross",20,"AGGREGATE","RAW","STACKED","INDEX"],"mappings":"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","file":"compass.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","module.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};","(function(f){if(typeof exports===\"object\"&&typeof module!==\"undefined\"){module.exports=f()}else if(typeof define===\"function\"&&define.amd){define([],f)}else{var g;if(typeof window!==\"undefined\"){g=window}else if(typeof global!==\"undefined\"){g=global}else if(typeof self!==\"undefined\"){g=self}else{g=this}g.cp = f()}})(function(){var define,module,exports;return (function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})({1:[function(require,module,exports){\nmodule.exports = {\n   hcluster: require(\"./hcluster\"),\n   Kmeans: require(\"./kmeans\"),\n   kmeans: require(\"./kmeans\").kmeans\n};\n},{\"./hcluster\":3,\"./kmeans\":4}],2:[function(require,module,exports){\nmodule.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};\n},{}],3:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n\n},{\"./distance\":2}],4:[function(require,module,exports){\nvar distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}\n},{\"./distance\":2}],5:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(encodings, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(encodings);\n\n  var clusterTrees = clusterfck.hcluster(encodings, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(encoding1, encoding2) {\n      // sort each cluster -- have the highest score as 1st item\n      return encoding2._info.score - encoding1._info.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0]._info.score - cluster1[0]._info.score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":19,\"./clusterconsts\":6,\"./distance\":7,\"clusterfck\":1}],6:[function(require,module,exports){\n'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n\n},{}],7:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e) { return distance.getEncTypeByColumnName(e); }),\n    shorthands = encodings.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (colenc1, colenc2) {\n  var cols = util.union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(colenc1),\n    isStack2 = vl.Encoding.isStack(colenc2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(colenc1.encoding.color.name !== colenc2.encoding.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.getEncTypeByColumnName = function(encoding) {\n  var _colenc = {},\n    enc = encoding.encoding;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.encType = encType;\n    _colenc[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc,\n    encoding: encoding.encoding\n  };\n};\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../util\":19,\"./clusterconsts\":6}],8:[function(require,module,exports){\n'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'mean']\n    },\n    timeUnitList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitOneDimensionCount: {\n      type: 'boolean',\n      default: false,\n      description: 'omit one dimension count'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n\n\n\n},{}],9:[function(require,module,exports){\nmodule.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n\n},{\"./cluster/cluster\":5,\"./consts\":8,\"./gen/gen\":13,\"./rank/rank\":17,\"./util\":19}],10:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null);\n\nvar consts = require('../consts');\n\nvar AUTO='*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fields.length);\n  var hasNorO = vl.any(fields, function(f) {\n    return vl.encDef.isTypes(f, [N, O]);\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.encDef.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.encDef.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.encDef.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fields[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === AUTO || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [AUTO, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vl.encDef.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [AUTO, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [AUTO, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignTimeUnitT(i, hasAggr, autoMode, timeUnit) {\n    tf[i].timeUnit = timeUnit;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].timeUnit;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fields[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._timeUnits\n    if (f._timeUnit) {\n      assignTimeUnitT(i, hasAggr, autoMode, f._timeUnit);\n    } else {\n      opt.timeUnitList.forEach(function(timeUnit) {\n        if (timeUnit === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignTimeUnitT(i, hasAggr, autoMode, timeUnit);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fields.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fields[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Q:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case T:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case O:\n        /* falls through */\n      case N:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, AUTO);\n\n  return output;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":8}],11:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genEncs = require('./encs'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genEncodingsFromFields;\n\nfunction genEncodingsFromFields(output, fields, stats, opt, nested) {\n  // opt must be augmented before being passed to genEncs or getMarktypes\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encs = genEncs([], fields, stats, opt);\n\n  if (nested) {\n    return encs.reduce(function(dict, enc) {\n      dict[enc] = genEncodingsFromEncs([], enc, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encs.reduce(function(list, enc) {\n      return genEncodingsFromEncs(list, enc, stats, opt);\n    }, []);\n  }\n}\n\nfunction genEncodingsFromEncs(output, enc, stats, opt) {\n  getMarktypes(enc, stats, opt)\n    .forEach(function(markType) {\n      var e = vl.duplicate({\n          // Clone config & encoding to unique objects\n          encoding: enc,\n          config: opt.config\n        });\n\n      e.marktype = markType;\n      // Data object is the same across charts: pass by reference\n      e.data = opt.data;\n\n      var encoding = finalTouch(e, stats, opt);\n      var score = rank.encoding(encoding, stats, opt);\n\n      encoding._info = score;\n      output.push(encoding);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(encoding, stats, opt) {\n  if (encoding.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    encoding.encoding.color = encoding.encoding.text;\n  }\n\n  // don't include zero if stdev/mean < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var enc = encoding.encoding;\n  ['x', 'y'].forEach(function(et) {\n    var field = enc[et];\n    if (field && vl.encDef.isMeasure(field) && !vl.encDef.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat && stat.stdev / stat.mean < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return encoding;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":8,\"../rank/rank\":17,\"./encs\":12,\"./marktypes\":14}],12:[function(require,module,exports){\n(function (global){\n\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.encDef.isDimension,\n  isMeasure = vl.encDef.isMeasure;\n\nmodule.exports = genEncs;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(enc, field, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (enc.color || enc.size || enc.shape) return false;\n  }\n  return true;\n}\n\nfunction colorRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  return vl.encDef.isMeasure(field) ||\n    vl.encDef.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  if (field.bin && field.type === Q) return false;\n  if (field.timeUnit && field.type === T) return false;\n  return vl.encDef.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(enc) {\n  // create horizontal histogram for ordinal\n  if (vl.encDef.isTypes(enc.y, [N, O]) && isMeasure(enc.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(enc.y) && (!vl.encDef.isTypes(enc.x, [N, O]) && isDimension(enc.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(enc, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (enc.text) {\n    return genMarkTypes.satisfyRules(enc, TEXT, stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (enc.x || enc.y || enc.geo || enc.arc) {\n\n    if (enc.row || enc.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!enc.x || !enc.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncs.isAggrWithAllDimOnFacets(enc)) return false;\n      }\n    }\n\n    if (enc.x && enc.y) {\n      var isDimX = !!isDimension(enc.x),\n        isDimY = !!isDimension(enc.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(enc)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(enc)) return false;\n        } else if (enc.y.type===T || enc.x.type === T) {\n          if (enc.y.type===T && enc.x.type !== T) return false;\n        } else { // show only one OxO, QxQ\n          if (enc.x.name > enc.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    if (opt.omitOneDimensionCount) {\n      // one dimension \"count\"\n    if (enc.x && enc.x.aggregate == 'count' && !enc.y) return false;\n    if (enc.y && enc.y.aggregate == 'count' && !enc.x) return false;\n    }\n\n    return true;\n  }\n  return false;\n}\n\ngenEncs.isAggrWithAllDimOnFacets = function (enc) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in enc) {\n    var field = enc[encType];\n    if (field.aggregate) {\n      hasAggr = true;\n    }\n    if (vl.encDef.isDimension(field) && (encType !== ROW && encType !== COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncs(encs, fields, stats, opt) {\n  // generate a collection vega-lite's enc\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEnc, stats, opt)) {\n        encs.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in opt.encodingTypeList) {\n      var et = opt.encodingTypeList[j],\n        isDim = isDimension(field);\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) && // encoding not used\n        ((isDim && rules[et].dimension) || (!isDim && rules[et].measure)) &&\n        (!rules[et].rules || rules[et].rules(tmpEnc, field, stats, opt))\n      ) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encs;\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../globals\":16,\"./marktypes\":14}],13:[function(require,module,exports){\n'use strict';\n\nvar util = require('../util');\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variatons\n  encodings: require('./encodings'),\n  encs: require('./encs'),\n  marktypes: require('./marktypes')\n};\n\ngen.charts = function(fields, opt, cfg, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fields, opt) : [fields],\n    encs, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encs = fieldSets.reduce(function(output, fields) {\n      return gen.encs(output, fields, opt);\n    }, []);\n  } else {\n    encs = fieldSets.map(function(fields) {\n      return gen.encs([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encs, function(output, enc) {\n      return gen.marktypes(output, enc, opt, cfg);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encs, function(enc) {\n      return gen.marktypes([], enc, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};\n},{\"../util\":19,\"./aggregates\":10,\"./encodings\":11,\"./encs\":12,\"./marktypes\":14,\"./projections\":15}],14:[function(require,module,exports){\n(function (global){\n\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension,\n  isOrdinalScale = vl.encDef.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(enc, stats, opt) {\n  return opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(enc, markType, stats, opt);\n  });\n}\n\nvlmarktypes.satisfyRules = function (enc, markType, stats, opt) {\n  var mark = vl.compiler.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in enc)) return false;\n  }\n\n  for (var encType in enc) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](enc, stats, opt);\n};\n\nfunction facetRule(field, stats, opt) {\n  return vl.encDef.cardinality(field, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(enc, stats, opt) {\n  if(enc.row && !facetRule(enc.row, stats, opt)) return false;\n  if(enc.col && !facetRule(enc.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDimension(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(enc, stats, opt) {\n  // jshint unused:false\n  if (enc.x || enc.y) {\n    if(vl.enc.isAggregate(enc)) return false;\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    return (!xIsDim && (!enc.y || isOrdinalScale(enc.y))) ||\n      (!yIsDim && (!enc.x || isOrdinalScale(enc.x)));\n  }\n  return false;\n}\n\nfunction barRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // bar requires at least x or y\n  if (!enc.x && !enc.y) return false;\n\n  if (opt.omitSizeOnBar && enc.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  // need to aggregate on either x or y\n  var aggEitherXorY =\n    (!enc.x || enc.x.aggregate === undefined) ^\n    (!enc.y || enc.y.aggregate === undefined);\n\n\n  if (aggEitherXorY) {\n    var eitherXorYisDimOrNull =\n      (!enc.x || isDimension(enc.x)) ^\n      (!enc.y || isDimension(enc.y));\n\n    if (eitherXorYisDimOrNull) {\n      var aggregate = enc.x.aggregate || enc.y.aggregate;\n      return !(opt.omitStackedAverage && aggregate ==='mean' && enc.color);\n    }\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x.type == 'T' && enc.x.timeUnit && enc.y.type == 'Q' && enc.y.aggregate;\n}\n\nfunction areaRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  if(!lineRule(enc, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && enc.y.aggregate ==='mean' && enc.color);\n}\n\nfunction textRule(enc, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (enc.row || enc.col) && enc.text && enc.text.aggregate && !enc.x && !enc.y && !enc.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !enc.color);\n}\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}],15:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fields array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fields.forEach(function(field, index){\n    //save indices for stable sort later\n    indices[field.name] = index;\n\n    if (field.selected) {\n      selected.push(field);\n      if (isDimension(field) || field.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (field.selected !== false && !vl.encDef.isCount(field)) {\n      if (vl.encDef.isDimension(field) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.encDef.cardinality(field, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(field);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  N: 0,\n  O: 0,\n  T: 2,\n  Q: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else { //if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.encDef.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../consts\":8,\"../util\":19}],16:[function(require,module,exports){\n(function (global){\n'use strict';\n\nvar g = global || window;\n\nrequire('vega-lite/src/globals');\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"vega-lite/src/globals\":20}],17:[function(require,module,exports){\nmodule.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n\n},{\"./rankEncodings\":18}],18:[function(require,module,exports){\n(function (global){\n'use strict';\n\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(encoding, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(encoding.encoding),\n    marktype = encoding.marktype,\n    enc = encoding.encoding;\n\n  var encodingMappingByField = vl.enc.reduce(encoding.encoding, function(o, field, encType) {\n    var key = vl.encDef.shorthand(field);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: field});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.encDef.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.encDef.isDimension(m.field) ? 'dimension' : 'measure';\n\n        var score = rankEncodings.score[role](m.field, m.encType, encoding.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === TEXT) {\n    // TODO\n  } else {\n    if (enc.x && enc.y) {\n      if (isDimension(enc.x) ^ isDimension(enc.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== TEXT) {\n    if ((!enc.x || !enc.y) && !enc.geo && !enc.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (field, encType, marktype, stats, opt){\n  var cardinality = vl.encDef.cardinality(field, stats);\n  switch (encType) {\n    case X:\n      if (vl.encDef.isTypes(field, [N, O]))  return D.pos - D.minor;\n      return D.pos;\n\n    case Y:\n      if (vl.encDef.isTypes(field, [N, O])) return D.pos - D.minor; //prefer ordinal on y\n      if(field.type === T) return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case COL:\n      if (marktype === TEXT) return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case ROW:\n      if (marktype === TEXT) return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case COLOR:\n      var hasOrder = (field.bin && field.type===Q) || (field.timeUnit && field.type===T);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype === 'bar' || marktype === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (field, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case X: return M.pos;\n    case Y: return M.pos;\n    case SIZE:\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === TEXT) return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case COLOR: return M.color;\n    case TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{\"../globals\":16}],19:[function(require,module,exports){\n\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n\n},{\"./consts\":8}],20:[function(require,module,exports){\n(function (global){\n'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n\n}).call(this,typeof global !== \"undefined\" ? global : typeof self !== \"undefined\" ? self : typeof window !== \"undefined\" ? window : {})\n\n},{}]},{},[9])(9)\n});\n//# sourceMappingURL=data:application/json;charset:utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIm5vZGVfbW9kdWxlcy9icm93c2VyaWZ5L25vZGVfbW9kdWxlcy9icm93c2VyLXBhY2svX3ByZWx1ZGUuanMiLCJub2RlX21vZHVsZXMvY2x1c3RlcmZjay9saWIvY2x1c3RlcmZjay5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9kaXN0YW5jZS5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9oY2x1c3Rlci5qcyIsIm5vZGVfbW9kdWxlcy9jbHVzdGVyZmNrL2xpYi9rbWVhbnMuanMiLCJzcmMvY2x1c3Rlci9jbHVzdGVyLmpzIiwic3JjL2NsdXN0ZXIvY2x1c3RlcmNvbnN0cy5qcyIsInNyYy9jbHVzdGVyL2Rpc3RhbmNlLmpzIiwic3JjL2NvbnN0cy5qcyIsInNyYy9jcCIsInNyYy9nZW4vYWdncmVnYXRlcy5qcyIsInNyYy9nZW4vZW5jb2RpbmdzLmpzIiwic3JjL2dlbi9lbmNzLmpzIiwic3JjL2dlbi9nZW4uanMiLCJzcmMvZ2VuL21hcmt0eXBlcy5qcyIsInNyYy9nZW4vcHJvamVjdGlvbnMuanMiLCJzcmMvZ2xvYmFscy5qcyIsInNyYy9yYW5rL3JhbmsuanMiLCJzcmMvcmFuay9yYW5rRW5jb2RpbmdzLmpzIiwic3JjL3V0aWwuanMiLCIuLi92ZWdhLWxpdGUvc3JjL2dsb2JhbHMuanMiXSwibmFtZXMiOltdLCJtYXBwaW5ncyI6IkFBQUE7QUNBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQ0pBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FDdEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUNqS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0dBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDdkNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDN0JBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM1RUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUN4TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDVkE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7Ozs7QUMvS0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDckVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDNU1BO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7OztBQzlDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7O0FDeEpBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7OztBQ2hHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7O0FDaEJBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FDTEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7Ozs7QUM3TEE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUN0SUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EiLCJmaWxlIjoiZ2VuZXJhdGVkLmpzIiwic291cmNlUm9vdCI6IiIsInNvdXJjZXNDb250ZW50IjpbIihmdW5jdGlvbiBlKHQsbixyKXtmdW5jdGlvbiBzKG8sdSl7aWYoIW5bb10pe2lmKCF0W29dKXt2YXIgYT10eXBlb2YgcmVxdWlyZT09XCJmdW5jdGlvblwiJiZyZXF1aXJlO2lmKCF1JiZhKXJldHVybiBhKG8sITApO2lmKGkpcmV0dXJuIGkobywhMCk7dmFyIGY9bmV3IEVycm9yKFwiQ2Fubm90IGZpbmQgbW9kdWxlICdcIitvK1wiJ1wiKTt0aHJvdyBmLmNvZGU9XCJNT0RVTEVfTk9UX0ZPVU5EXCIsZn12YXIgbD1uW29dPXtleHBvcnRzOnt9fTt0W29dWzBdLmNhbGwobC5leHBvcnRzLGZ1bmN0aW9uKGUpe3ZhciBuPXRbb11bMV1bZV07cmV0dXJuIHMobj9uOmUpfSxsLGwuZXhwb3J0cyxlLHQsbixyKX1yZXR1cm4gbltvXS5leHBvcnRzfXZhciBpPXR5cGVvZiByZXF1aXJlPT1cImZ1bmN0aW9uXCImJnJlcXVpcmU7Zm9yKHZhciBvPTA7bzxyLmxlbmd0aDtvKyspcyhyW29dKTtyZXR1cm4gc30pIiwibW9kdWxlLmV4cG9ydHMgPSB7XG4gICBoY2x1c3RlcjogcmVxdWlyZShcIi4vaGNsdXN0ZXJcIiksXG4gICBLbWVhbnM6IHJlcXVpcmUoXCIuL2ttZWFuc1wiKSxcbiAgIGttZWFuczogcmVxdWlyZShcIi4va21lYW5zXCIpLmttZWFuc1xufTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZXVjbGlkZWFuOiBmdW5jdGlvbih2MSwgdjIpIHtcbiAgICAgIHZhciB0b3RhbCA9IDA7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHYxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICB0b3RhbCArPSBNYXRoLnBvdyh2MltpXSAtIHYxW2ldLCAyKTsgICAgICBcbiAgICAgIH1cbiAgICAgIHJldHVybiBNYXRoLnNxcnQodG90YWwpO1xuICAgfSxcbiAgIG1hbmhhdHRhbjogZnVuY3Rpb24odjEsIHYyKSB7XG4gICAgIHZhciB0b3RhbCA9IDA7XG4gICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdjEubGVuZ3RoIDsgaSsrKSB7XG4gICAgICAgIHRvdGFsICs9IE1hdGguYWJzKHYyW2ldIC0gdjFbaV0pOyAgICAgIFxuICAgICB9XG4gICAgIHJldHVybiB0b3RhbDtcbiAgIH0sXG4gICBtYXg6IGZ1bmN0aW9uKHYxLCB2Mikge1xuICAgICB2YXIgbWF4ID0gMDtcbiAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2MS5sZW5ndGg7IGkrKykge1xuICAgICAgICBtYXggPSBNYXRoLm1heChtYXggLCBNYXRoLmFicyh2MltpXSAtIHYxW2ldKSk7ICAgICAgXG4gICAgIH1cbiAgICAgcmV0dXJuIG1heDtcbiAgIH1cbn07IiwidmFyIGRpc3RhbmNlcyA9IHJlcXVpcmUoXCIuL2Rpc3RhbmNlXCIpO1xuXG52YXIgSGllcmFyY2hpY2FsQ2x1c3RlcmluZyA9IGZ1bmN0aW9uKGRpc3RhbmNlLCBsaW5rYWdlLCB0aHJlc2hvbGQpIHtcbiAgIHRoaXMuZGlzdGFuY2UgPSBkaXN0YW5jZTtcbiAgIHRoaXMubGlua2FnZSA9IGxpbmthZ2U7XG4gICB0aGlzLnRocmVzaG9sZCA9IHRocmVzaG9sZCA9PSB1bmRlZmluZWQgPyBJbmZpbml0eSA6IHRocmVzaG9sZDtcbn1cblxuSGllcmFyY2hpY2FsQ2x1c3RlcmluZy5wcm90b3R5cGUgPSB7XG4gICBjbHVzdGVyIDogZnVuY3Rpb24oaXRlbXMsIHNuYXBzaG90UGVyaW9kLCBzbmFwc2hvdENiKSB7XG4gICAgICB0aGlzLmNsdXN0ZXJzID0gW107XG4gICAgICB0aGlzLmRpc3RzID0gW107ICAvLyBkaXN0YW5jZXMgYmV0d2VlbiBlYWNoIHBhaXIgb2YgY2x1c3RlcnNcbiAgICAgIHRoaXMubWlucyA9IFtdOyAvLyBjbG9zZXN0IGNsdXN0ZXIgZm9yIGVhY2ggY2x1c3RlclxuICAgICAgdGhpcy5pbmRleCA9IFtdOyAvLyBrZWVwIGEgaGFzaCBvZiBhbGwgY2x1c3RlcnMgYnkga2V5XG4gICAgICBcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaXRlbXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIHZhciBjbHVzdGVyID0ge1xuICAgICAgICAgICAgdmFsdWU6IGl0ZW1zW2ldLFxuICAgICAgICAgICAga2V5OiBpLFxuICAgICAgICAgICAgaW5kZXg6IGksXG4gICAgICAgICAgICBzaXplOiAxXG4gICAgICAgICB9O1xuICAgICAgICAgdGhpcy5jbHVzdGVyc1tpXSA9IGNsdXN0ZXI7XG4gICAgICAgICB0aGlzLmluZGV4W2ldID0gY2x1c3RlcjtcbiAgICAgICAgIHRoaXMuZGlzdHNbaV0gPSBbXTtcbiAgICAgICAgIHRoaXMubWluc1tpXSA9IDA7XG4gICAgICB9XG5cbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgZm9yICh2YXIgaiA9IDA7IGogPD0gaTsgaisrKSB7XG4gICAgICAgICAgICB2YXIgZGlzdCA9IChpID09IGopID8gSW5maW5pdHkgOiBcbiAgICAgICAgICAgICAgIHRoaXMuZGlzdGFuY2UodGhpcy5jbHVzdGVyc1tpXS52YWx1ZSwgdGhpcy5jbHVzdGVyc1tqXS52YWx1ZSk7XG4gICAgICAgICAgICB0aGlzLmRpc3RzW2ldW2pdID0gZGlzdDtcbiAgICAgICAgICAgIHRoaXMuZGlzdHNbal1baV0gPSBkaXN0O1xuXG4gICAgICAgICAgICBpZiAoZGlzdCA8IHRoaXMuZGlzdHNbaV1bdGhpcy5taW5zW2ldXSkge1xuICAgICAgICAgICAgICAgdGhpcy5taW5zW2ldID0gajsgICAgICAgICAgICAgICBcbiAgICAgICAgICAgIH1cbiAgICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdmFyIG1lcmdlZCA9IHRoaXMubWVyZ2VDbG9zZXN0KCk7XG4gICAgICB2YXIgaSA9IDA7XG4gICAgICB3aGlsZSAobWVyZ2VkKSB7XG4gICAgICAgIGlmIChzbmFwc2hvdENiICYmIChpKysgJSBzbmFwc2hvdFBlcmlvZCkgPT0gMCkge1xuICAgICAgICAgICBzbmFwc2hvdENiKHRoaXMuY2x1c3RlcnMpOyAgICAgICAgICAgXG4gICAgICAgIH1cbiAgICAgICAgbWVyZ2VkID0gdGhpcy5tZXJnZUNsb3Nlc3QoKTtcbiAgICAgIH1cbiAgICBcbiAgICAgIHRoaXMuY2x1c3RlcnMuZm9yRWFjaChmdW5jdGlvbihjbHVzdGVyKSB7XG4gICAgICAgIC8vIGNsZWFuIHVwIG1ldGFkYXRhIHVzZWQgZm9yIGNsdXN0ZXJpbmdcbiAgICAgICAgZGVsZXRlIGNsdXN0ZXIua2V5O1xuICAgICAgICBkZWxldGUgY2x1c3Rlci5pbmRleDtcbiAgICAgIH0pO1xuXG4gICAgICByZXR1cm4gdGhpcy5jbHVzdGVycztcbiAgIH0sXG4gIFxuICAgbWVyZ2VDbG9zZXN0OiBmdW5jdGlvbigpIHtcbiAgICAgIC8vIGZpbmQgdHdvIGNsb3Nlc3QgY2x1c3RlcnMgZnJvbSBjYWNoZWQgbWluc1xuICAgICAgdmFyIG1pbktleSA9IDAsIG1pbiA9IEluZmluaXR5O1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICB2YXIga2V5ID0gdGhpcy5jbHVzdGVyc1tpXS5rZXksXG4gICAgICAgICAgICAgZGlzdCA9IHRoaXMuZGlzdHNba2V5XVt0aGlzLm1pbnNba2V5XV07XG4gICAgICAgICBpZiAoZGlzdCA8IG1pbikge1xuICAgICAgICAgICAgbWluS2V5ID0ga2V5O1xuICAgICAgICAgICAgbWluID0gZGlzdDtcbiAgICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChtaW4gPj0gdGhpcy50aHJlc2hvbGQpIHtcbiAgICAgICAgIHJldHVybiBmYWxzZTsgICAgICAgICBcbiAgICAgIH1cblxuICAgICAgdmFyIGMxID0gdGhpcy5pbmRleFttaW5LZXldLFxuICAgICAgICAgIGMyID0gdGhpcy5pbmRleFt0aGlzLm1pbnNbbWluS2V5XV07XG5cbiAgICAgIC8vIG1lcmdlIHR3byBjbG9zZXN0IGNsdXN0ZXJzXG4gICAgICB2YXIgbWVyZ2VkID0ge1xuICAgICAgICAgbGVmdDogYzEsXG4gICAgICAgICByaWdodDogYzIsXG4gICAgICAgICBrZXk6IGMxLmtleSxcbiAgICAgICAgIHNpemU6IGMxLnNpemUgKyBjMi5zaXplXG4gICAgICB9O1xuXG4gICAgICB0aGlzLmNsdXN0ZXJzW2MxLmluZGV4XSA9IG1lcmdlZDtcbiAgICAgIHRoaXMuY2x1c3RlcnMuc3BsaWNlKGMyLmluZGV4LCAxKTtcbiAgICAgIHRoaXMuaW5kZXhbYzEua2V5XSA9IG1lcmdlZDtcblxuICAgICAgLy8gdXBkYXRlIGRpc3RhbmNlcyB3aXRoIG5ldyBtZXJnZWQgY2x1c3RlclxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICB2YXIgY2kgPSB0aGlzLmNsdXN0ZXJzW2ldO1xuICAgICAgICAgdmFyIGRpc3Q7XG4gICAgICAgICBpZiAoYzEua2V5ID09IGNpLmtleSkge1xuICAgICAgICAgICAgZGlzdCA9IEluZmluaXR5OyAgICAgICAgICAgIFxuICAgICAgICAgfVxuICAgICAgICAgZWxzZSBpZiAodGhpcy5saW5rYWdlID09IFwic2luZ2xlXCIpIHtcbiAgICAgICAgICAgIGRpc3QgPSB0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XTtcbiAgICAgICAgICAgIGlmICh0aGlzLmRpc3RzW2MxLmtleV1bY2kua2V5XSA+IHRoaXMuZGlzdHNbYzIua2V5XVtjaS5rZXldKSB7XG4gICAgICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0c1tjMi5rZXldW2NpLmtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLmxpbmthZ2UgPT0gXCJjb21wbGV0ZVwiKSB7XG4gICAgICAgICAgICBkaXN0ID0gdGhpcy5kaXN0c1tjMS5rZXldW2NpLmtleV07XG4gICAgICAgICAgICBpZiAodGhpcy5kaXN0c1tjMS5rZXldW2NpLmtleV0gPCB0aGlzLmRpc3RzW2MyLmtleV1bY2kua2V5XSkge1xuICAgICAgICAgICAgICAgZGlzdCA9IHRoaXMuZGlzdHNbYzIua2V5XVtjaS5rZXldOyAgICAgICAgICAgICAgXG4gICAgICAgICAgICB9XG4gICAgICAgICB9XG4gICAgICAgICBlbHNlIGlmICh0aGlzLmxpbmthZ2UgPT0gXCJhdmVyYWdlXCIpIHtcbiAgICAgICAgICAgIGRpc3QgPSAodGhpcy5kaXN0c1tjMS5rZXldW2NpLmtleV0gKiBjMS5zaXplXG4gICAgICAgICAgICAgICAgICAgKyB0aGlzLmRpc3RzW2MyLmtleV1bY2kua2V5XSAqIGMyLnNpemUpIC8gKGMxLnNpemUgKyBjMi5zaXplKTtcbiAgICAgICAgIH1cbiAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZGlzdCA9IHRoaXMuZGlzdGFuY2UoY2kudmFsdWUsIGMxLnZhbHVlKTsgICAgICAgICAgICBcbiAgICAgICAgIH1cblxuICAgICAgICAgdGhpcy5kaXN0c1tjMS5rZXldW2NpLmtleV0gPSB0aGlzLmRpc3RzW2NpLmtleV1bYzEua2V5XSA9IGRpc3Q7XG4gICAgICB9XG5cbiAgICBcbiAgICAgIC8vIHVwZGF0ZSBjYWNoZWQgbWluc1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmNsdXN0ZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICB2YXIga2V5MSA9IHRoaXMuY2x1c3RlcnNbaV0ua2V5OyAgICAgICAgXG4gICAgICAgICBpZiAodGhpcy5taW5zW2tleTFdID09IGMxLmtleSB8fCB0aGlzLm1pbnNba2V5MV0gPT0gYzIua2V5KSB7XG4gICAgICAgICAgICB2YXIgbWluID0ga2V5MTtcbiAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgdGhpcy5jbHVzdGVycy5sZW5ndGg7IGorKykge1xuICAgICAgICAgICAgICAgdmFyIGtleTIgPSB0aGlzLmNsdXN0ZXJzW2pdLmtleTtcbiAgICAgICAgICAgICAgIGlmICh0aGlzLmRpc3RzW2tleTFdW2tleTJdIDwgdGhpcy5kaXN0c1trZXkxXVttaW5dKSB7XG4gICAgICAgICAgICAgICAgICBtaW4gPSBrZXkyOyAgICAgICAgICAgICAgICAgIFxuICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5taW5zW2tleTFdID0gbWluO1xuICAgICAgICAgfVxuICAgICAgICAgdGhpcy5jbHVzdGVyc1tpXS5pbmRleCA9IGk7XG4gICAgICB9XG4gICAgXG4gICAgICAvLyBjbGVhbiB1cCBtZXRhZGF0YSB1c2VkIGZvciBjbHVzdGVyaW5nXG4gICAgICBkZWxldGUgYzEua2V5OyBkZWxldGUgYzIua2V5O1xuICAgICAgZGVsZXRlIGMxLmluZGV4OyBkZWxldGUgYzIuaW5kZXg7XG5cbiAgICAgIHJldHVybiB0cnVlO1xuICAgfVxufVxuXG52YXIgaGNsdXN0ZXIgPSBmdW5jdGlvbihpdGVtcywgZGlzdGFuY2UsIGxpbmthZ2UsIHRocmVzaG9sZCwgc25hcHNob3QsIHNuYXBzaG90Q2FsbGJhY2spIHtcbiAgIGRpc3RhbmNlID0gZGlzdGFuY2UgfHwgXCJldWNsaWRlYW5cIjtcbiAgIGxpbmthZ2UgPSBsaW5rYWdlIHx8IFwiYXZlcmFnZVwiO1xuXG4gICBpZiAodHlwZW9mIGRpc3RhbmNlID09IFwic3RyaW5nXCIpIHtcbiAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZXNbZGlzdGFuY2VdO1xuICAgfVxuICAgdmFyIGNsdXN0ZXJzID0gKG5ldyBIaWVyYXJjaGljYWxDbHVzdGVyaW5nKGRpc3RhbmNlLCBsaW5rYWdlLCB0aHJlc2hvbGQpKVxuICAgICAgICAgICAgICAgICAgLmNsdXN0ZXIoaXRlbXMsIHNuYXBzaG90LCBzbmFwc2hvdENhbGxiYWNrKTtcbiAgICAgIFxuICAgaWYgKHRocmVzaG9sZCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gY2x1c3RlcnNbMF07IC8vIGFsbCBjbHVzdGVyZWQgaW50byBvbmVcbiAgIH1cbiAgIHJldHVybiBjbHVzdGVycztcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBoY2x1c3RlcjtcbiIsInZhciBkaXN0YW5jZXMgPSByZXF1aXJlKFwiLi9kaXN0YW5jZVwiKTtcblxuZnVuY3Rpb24gS01lYW5zKGNlbnRyb2lkcykge1xuICAgdGhpcy5jZW50cm9pZHMgPSBjZW50cm9pZHMgfHwgW107XG59XG5cbktNZWFucy5wcm90b3R5cGUucmFuZG9tQ2VudHJvaWRzID0gZnVuY3Rpb24ocG9pbnRzLCBrKSB7XG4gICB2YXIgY2VudHJvaWRzID0gcG9pbnRzLnNsaWNlKDApOyAvLyBjb3B5XG4gICBjZW50cm9pZHMuc29ydChmdW5jdGlvbigpIHtcbiAgICAgIHJldHVybiAoTWF0aC5yb3VuZChNYXRoLnJhbmRvbSgpKSAtIDAuNSk7XG4gICB9KTtcbiAgIHJldHVybiBjZW50cm9pZHMuc2xpY2UoMCwgayk7XG59XG5cbktNZWFucy5wcm90b3R5cGUuY2xhc3NpZnkgPSBmdW5jdGlvbihwb2ludCwgZGlzdGFuY2UpIHtcbiAgIHZhciBtaW4gPSBJbmZpbml0eSxcbiAgICAgICBpbmRleCA9IDA7XG5cbiAgIGRpc3RhbmNlID0gZGlzdGFuY2UgfHwgXCJldWNsaWRlYW5cIjtcbiAgIGlmICh0eXBlb2YgZGlzdGFuY2UgPT0gXCJzdHJpbmdcIikge1xuICAgICAgZGlzdGFuY2UgPSBkaXN0YW5jZXNbZGlzdGFuY2VdO1xuICAgfVxuXG4gICBmb3IgKHZhciBpID0gMDsgaSA8IHRoaXMuY2VudHJvaWRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGlzdCA9IGRpc3RhbmNlKHBvaW50LCB0aGlzLmNlbnRyb2lkc1tpXSk7XG4gICAgICBpZiAoZGlzdCA8IG1pbikge1xuICAgICAgICAgbWluID0gZGlzdDtcbiAgICAgICAgIGluZGV4ID0gaTtcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIGluZGV4O1xufVxuXG5LTWVhbnMucHJvdG90eXBlLmNsdXN0ZXIgPSBmdW5jdGlvbihwb2ludHMsIGssIGRpc3RhbmNlLCBzbmFwc2hvdFBlcmlvZCwgc25hcHNob3RDYikge1xuICAgayA9IGsgfHwgTWF0aC5tYXgoMiwgTWF0aC5jZWlsKE1hdGguc3FydChwb2ludHMubGVuZ3RoIC8gMikpKTtcblxuICAgZGlzdGFuY2UgPSBkaXN0YW5jZSB8fCBcImV1Y2xpZGVhblwiO1xuICAgaWYgKHR5cGVvZiBkaXN0YW5jZSA9PSBcInN0cmluZ1wiKSB7XG4gICAgICBkaXN0YW5jZSA9IGRpc3RhbmNlc1tkaXN0YW5jZV07XG4gICB9XG5cbiAgIHRoaXMuY2VudHJvaWRzID0gdGhpcy5yYW5kb21DZW50cm9pZHMocG9pbnRzLCBrKTtcblxuICAgdmFyIGFzc2lnbm1lbnQgPSBuZXcgQXJyYXkocG9pbnRzLmxlbmd0aCk7XG4gICB2YXIgY2x1c3RlcnMgPSBuZXcgQXJyYXkoayk7XG5cbiAgIHZhciBpdGVyYXRpb25zID0gMDtcbiAgIHZhciBtb3ZlbWVudCA9IHRydWU7XG4gICB3aGlsZSAobW92ZW1lbnQpIHtcbiAgICAgIC8vIHVwZGF0ZSBwb2ludC10by1jZW50cm9pZCBhc3NpZ25tZW50c1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwb2ludHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgIGFzc2lnbm1lbnRbaV0gPSB0aGlzLmNsYXNzaWZ5KHBvaW50c1tpXSwgZGlzdGFuY2UpO1xuICAgICAgfVxuXG4gICAgICAvLyB1cGRhdGUgbG9jYXRpb24gb2YgZWFjaCBjZW50cm9pZFxuICAgICAgbW92ZW1lbnQgPSBmYWxzZTtcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgazsgaisrKSB7XG4gICAgICAgICB2YXIgYXNzaWduZWQgPSBbXTtcbiAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgYXNzaWdubWVudC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgaWYgKGFzc2lnbm1lbnRbaV0gPT0gaikge1xuICAgICAgICAgICAgICAgYXNzaWduZWQucHVzaChwb2ludHNbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICBpZiAoIWFzc2lnbmVkLmxlbmd0aCkge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICB9XG5cbiAgICAgICAgIHZhciBjZW50cm9pZCA9IHRoaXMuY2VudHJvaWRzW2pdO1xuICAgICAgICAgdmFyIG5ld0NlbnRyb2lkID0gbmV3IEFycmF5KGNlbnRyb2lkLmxlbmd0aCk7XG5cbiAgICAgICAgIGZvciAodmFyIGcgPSAwOyBnIDwgY2VudHJvaWQubGVuZ3RoOyBnKyspIHtcbiAgICAgICAgICAgIHZhciBzdW0gPSAwO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhc3NpZ25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgc3VtICs9IGFzc2lnbmVkW2ldW2ddO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbmV3Q2VudHJvaWRbZ10gPSBzdW0gLyBhc3NpZ25lZC5sZW5ndGg7XG5cbiAgICAgICAgICAgIGlmIChuZXdDZW50cm9pZFtnXSAhPSBjZW50cm9pZFtnXSkge1xuICAgICAgICAgICAgICAgbW92ZW1lbnQgPSB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgfVxuXG4gICAgICAgICB0aGlzLmNlbnRyb2lkc1tqXSA9IG5ld0NlbnRyb2lkO1xuICAgICAgICAgY2x1c3RlcnNbal0gPSBhc3NpZ25lZDtcbiAgICAgIH1cblxuICAgICAgaWYgKHNuYXBzaG90Q2IgJiYgKGl0ZXJhdGlvbnMrKyAlIHNuYXBzaG90UGVyaW9kID09IDApKSB7XG4gICAgICAgICBzbmFwc2hvdENiKGNsdXN0ZXJzKTtcbiAgICAgIH1cbiAgIH1cblxuICAgcmV0dXJuIGNsdXN0ZXJzO1xufVxuXG5LTWVhbnMucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uKCkge1xuICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHRoaXMuY2VudHJvaWRzKTtcbn1cblxuS01lYW5zLnByb3RvdHlwZS5mcm9tSlNPTiA9IGZ1bmN0aW9uKGpzb24pIHtcbiAgIHRoaXMuY2VudHJvaWRzID0gSlNPTi5wYXJzZShqc29uKTtcbiAgIHJldHVybiB0aGlzO1xufVxuXG5tb2R1bGUuZXhwb3J0cyA9IEtNZWFucztcblxubW9kdWxlLmV4cG9ydHMua21lYW5zID0gZnVuY3Rpb24odmVjdG9ycywgaykge1xuICAgcmV0dXJuIChuZXcgS01lYW5zKCkpLmNsdXN0ZXIodmVjdG9ycywgayk7XG59IiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbm1vZHVsZS5leHBvcnRzID0gY2x1c3RlcjtcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZsJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2bCddIDogbnVsbCksXG4gIGNsdXN0ZXJmY2sgPSByZXF1aXJlKCdjbHVzdGVyZmNrJyksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4vY2x1c3RlcmNvbnN0cycpLFxuICB1dGlsID0gcmVxdWlyZSgnLi4vdXRpbCcpO1xuXG5jbHVzdGVyLmRpc3RhbmNlID0gcmVxdWlyZSgnLi9kaXN0YW5jZScpO1xuXG5mdW5jdGlvbiBjbHVzdGVyKGVuY29kaW5ncywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgdmFyIGRpc3QgPSBjbHVzdGVyLmRpc3RhbmNlLnRhYmxlKGVuY29kaW5ncyk7XG5cbiAgdmFyIGNsdXN0ZXJUcmVlcyA9IGNsdXN0ZXJmY2suaGNsdXN0ZXIoZW5jb2RpbmdzLCBmdW5jdGlvbihlMSwgZTIpIHtcbiAgICB2YXIgczEgPSB2bC5FbmNvZGluZy5zaG9ydGhhbmQoZTEpLFxuICAgICAgczIgPSB2bC5FbmNvZGluZy5zaG9ydGhhbmQoZTIpO1xuICAgIHJldHVybiBkaXN0W3MxXVtzMl07XG4gIH0sICdhdmVyYWdlJywgY29uc3RzLkNMVVNURVJfVEhSRVNIT0xEKTtcblxuICB2YXIgY2x1c3RlcnMgPSBjbHVzdGVyVHJlZXMubWFwKGZ1bmN0aW9uKHRyZWUpIHtcbiAgICAgIHJldHVybiB1dGlsLnRyYXZlcnNlKHRyZWUsIFtdKTtcbiAgICB9KVxuICAgLm1hcChmdW5jdGlvbihjbHVzdGVyKSB7XG4gICAgcmV0dXJuIGNsdXN0ZXIuc29ydChmdW5jdGlvbihlbmNvZGluZzEsIGVuY29kaW5nMikge1xuICAgICAgLy8gc29ydCBlYWNoIGNsdXN0ZXIgLS0gaGF2ZSB0aGUgaGlnaGVzdCBzY29yZSBhcyAxc3QgaXRlbVxuICAgICAgcmV0dXJuIGVuY29kaW5nMi5faW5mby5zY29yZSAtIGVuY29kaW5nMS5faW5mby5zY29yZTtcbiAgICB9KTtcbiAgfSkuZmlsdGVyKGZ1bmN0aW9uKGNsdXN0ZXIpIHsgIC8vIGZpbHRlciBlbXB0eSBjbHVzdGVyXG4gICAgcmV0dXJuIGNsdXN0ZXIubGVuZ3RoID4wO1xuICB9KS5zb3J0KGZ1bmN0aW9uKGNsdXN0ZXIxLCBjbHVzdGVyMikge1xuICAgIC8vc29ydCBieSBoaWdoZXN0IHNjb3JpbmcgaXRlbSBpbiBlYWNoIGNsdXN0ZXJcbiAgICByZXR1cm4gY2x1c3RlcjJbMF0uX2luZm8uc2NvcmUgLSBjbHVzdGVyMVswXS5faW5mby5zY29yZTtcbiAgfSk7XG5cbiAgY2x1c3RlcnMuZGlzdCA9IGRpc3Q7IC8vYXBwZW5kIGRpc3QgaW4gdGhlIGFycmF5IGZvciBkZWJ1Z2dpbmdcblxuICByZXR1cm4gY2x1c3RlcnM7XG59IiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgYyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbmMuU1dBUFBBQkxFID0gMC4wNTtcbmMuRElTVF9NSVNTSU5HID0gMTtcbmMuQ0xVU1RFUl9USFJFU0hPTEQgPSAxO1xuXG5mdW5jdGlvbiByZWR1Y2VUdXBsZVRvVGFibGUociwgeCkge1xuICB2YXIgYSA9IHhbMF0sIGIgPSB4WzFdLCBkID0geFsyXTtcbiAgclthXSA9IHJbYV0gfHwge307XG4gIHJbYl0gPSByW2JdIHx8IHt9O1xuICByW2FdW2JdID0gcltiXVthXSA9IGQ7XG4gIHJldHVybiByO1xufVxuXG5jLkRJU1RfQllfRU5DVFlQRSA9IFtcbiAgLy8gcG9zaXRpb25hbFxuICBbJ3gnLCAneScsIGMuU1dBUFBBQkxFXSxcbiAgWydyb3cnLCAnY29sJywgYy5TV0FQUEFCTEVdLFxuXG4gIC8vIG9yZGluYWwgbWFyayBwcm9wZXJ0aWVzXG4gIFsnY29sb3InLCAnc2hhcGUnLCBjLlNXQVBQQUJMRV0sXG4gIFsnY29sb3InLCAnZGV0YWlsJywgYy5TV0FQUEFCTEVdLFxuICBbJ2RldGFpbCcsICdzaGFwZScsIGMuU1dBUFBBQkxFXSxcblxuICAvLyBxdWFudGl0YXRpdmUgbWFyayBwcm9wZXJ0aWVzXG4gIFsnc2l6ZScsICdjb2xvcicsIGMuU1dBUFBBQkxFXVxuXS5yZWR1Y2UocmVkdWNlVHVwbGVUb1RhYmxlLCB7fSk7XG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpLFxuICBjb25zdHMgPSByZXF1aXJlKCcuL2NsdXN0ZXJjb25zdHMnKSxcbiAgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGRpc3RhbmNlID0ge307XG5tb2R1bGUuZXhwb3J0cyA9IGRpc3RhbmNlO1xuXG5kaXN0YW5jZS50YWJsZSA9IGZ1bmN0aW9uIChlbmNvZGluZ3MpIHtcbiAgdmFyIGxlbiA9IGVuY29kaW5ncy5sZW5ndGgsXG4gICAgY29sZW5jcyA9IGVuY29kaW5ncy5tYXAoZnVuY3Rpb24oZSkgeyByZXR1cm4gZGlzdGFuY2UuZ2V0RW5jVHlwZUJ5Q29sdW1uTmFtZShlKTsgfSksXG4gICAgc2hvcnRoYW5kcyA9IGVuY29kaW5ncy5tYXAodmwuRW5jb2Rpbmcuc2hvcnRoYW5kKSxcbiAgICBkaWZmID0ge30sIGksIGo7XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSBkaWZmW3Nob3J0aGFuZHNbaV1dID0ge307XG5cbiAgZm9yIChpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgZm9yIChqID0gaSArIDE7IGogPCBsZW47IGorKykge1xuICAgICAgdmFyIHNqID0gc2hvcnRoYW5kc1tqXSwgc2kgPSBzaG9ydGhhbmRzW2ldO1xuXG4gICAgICBkaWZmW3NqXVtzaV0gPSBkaWZmW3NpXVtzal0gPSBkaXN0YW5jZS5nZXQoY29sZW5jc1tpXSwgY29sZW5jc1tqXSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBkaWZmO1xufTtcblxuZGlzdGFuY2UuZ2V0ID0gZnVuY3Rpb24gKGNvbGVuYzEsIGNvbGVuYzIpIHtcbiAgdmFyIGNvbHMgPSB1dGlsLnVuaW9uKHZsLmtleXMoY29sZW5jMS5jb2wpLCB2bC5rZXlzKGNvbGVuYzIuY29sKSksXG4gICAgZGlzdCA9IDA7XG5cbiAgY29scy5mb3JFYWNoKGZ1bmN0aW9uKGNvbCkge1xuICAgIHZhciBlMSA9IGNvbGVuYzEuY29sW2NvbF0sIGUyID0gY29sZW5jMi5jb2xbY29sXTtcblxuICAgIGlmIChlMSAmJiBlMikge1xuICAgICAgaWYgKGUxLmVuY1R5cGUgIT0gZTIuZW5jVHlwZSkge1xuICAgICAgICBkaXN0ICs9IChjb25zdHMuRElTVF9CWV9FTkNUWVBFW2UxLmVuY1R5cGVdIHx8IHt9KVtlMi5lbmNUeXBlXSB8fCAxO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICBkaXN0ICs9IGNvbnN0cy5ESVNUX01JU1NJTkc7XG4gICAgfVxuICB9KTtcblxuICAvLyBkbyBub3QgZ3JvdXAgc3RhY2tlZCBjaGFydCB3aXRoIHNpbWlsYXIgbm9uLXN0YWNrZWQgY2hhcnQhXG4gIHZhciBpc1N0YWNrMSA9IHZsLkVuY29kaW5nLmlzU3RhY2soY29sZW5jMSksXG4gICAgaXNTdGFjazIgPSB2bC5FbmNvZGluZy5pc1N0YWNrKGNvbGVuYzIpO1xuXG4gIGlmKGlzU3RhY2sxIHx8IGlzU3RhY2syKSB7XG4gICAgaWYoaXNTdGFjazEgJiYgaXNTdGFjazIpIHtcbiAgICAgIGlmKGNvbGVuYzEuZW5jb2RpbmcuY29sb3IubmFtZSAhPT0gY29sZW5jMi5lbmNvZGluZy5jb2xvci5uYW1lKSB7XG4gICAgICAgIGRpc3QrPTE7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGRpc3QrPTE7IC8vIHN1cmVseSBkaWZmZXJlbnRcbiAgICB9XG4gIH1cbiAgcmV0dXJuIGRpc3Q7XG59O1xuXG4vLyBnZXQgZW5jb2RpbmcgdHlwZSBieSBmaWVsZG5hbWVcbmRpc3RhbmNlLmdldEVuY1R5cGVCeUNvbHVtbk5hbWUgPSBmdW5jdGlvbihlbmNvZGluZykge1xuICB2YXIgX2NvbGVuYyA9IHt9LFxuICAgIGVuYyA9IGVuY29kaW5nLmVuY29kaW5nO1xuXG4gIHZsLmtleXMoZW5jKS5mb3JFYWNoKGZ1bmN0aW9uKGVuY1R5cGUpIHtcbiAgICB2YXIgZSA9IHZsLmR1cGxpY2F0ZShlbmNbZW5jVHlwZV0pO1xuICAgIGUuZW5jVHlwZSA9IGVuY1R5cGU7XG4gICAgX2NvbGVuY1tlLm5hbWUgfHwgJyddID0gZTtcbiAgICBkZWxldGUgZS5uYW1lO1xuICB9KTtcblxuICByZXR1cm4ge1xuICAgIG1hcmt0eXBlOiBlbmNvZGluZy5tYXJrdHlwZSxcbiAgICBjb2w6IF9jb2xlbmMsXG4gICAgZW5jb2Rpbmc6IGVuY29kaW5nLmVuY29kaW5nXG4gIH07XG59OyIsIid1c2Ugc3RyaWN0JztcblxudmFyIGNvbnN0cyA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBnZW46IHt9LFxuICBjbHVzdGVyOiB7fSxcbiAgcmFuazoge31cbn07XG5cbmNvbnN0cy5nZW4ucHJvamVjdGlvbnMgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgb21pdERvdFBsb3Q6IHsgLy9GSVhNRSByZW1vdmUgdGhpcyFcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdyZW1vdmUgYWxsIGRvdCBwbG90cydcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yQXV0b0FkZE9yZGluYWw6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDUwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXggY2FyZGluYWxpdHkgZm9yIG9yZGluYWwgZmllbGQgdG8gYmUgY29uc2lkZXJlZCBmb3IgYXV0byBhZGRpbmcnXG4gICAgfSxcbiAgICBhbHdheXNBZGRIaXN0b2dyYW06IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cbmNvbnN0cy5nZW4uYWdncmVnYXRlcyA9IHtcbiAgdHlwZTogJ29iamVjdCcsXG4gIHByb3BlcnRpZXM6IHtcbiAgICBjb25maWc6IHtcbiAgICAgIHR5cGU6ICdvYmplY3QnXG4gICAgfSxcbiAgICBkYXRhOiB7XG4gICAgICB0eXBlOiAnb2JqZWN0J1xuICAgIH0sXG4gICAgdGFibGVUeXBlczoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogJ2JvdGgnLFxuICAgICAgZW51bTogWydib3RoJywgJ2FnZ3JlZ2F0ZWQnLCAnZGlzYWdncmVnYXRlZCddXG4gICAgfSxcbiAgICBnZW5EaW1ROiB7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGRlZmF1bHQ6ICdhdXRvJyxcbiAgICAgIGVudW06IFsnYXV0bycsICdiaW4nLCAnY2FzdCcsICdub25lJ10sXG4gICAgICBkZXNjcmlwdGlvbjogJ1VzZSBRIGFzIERpbWVuc2lvbiBlaXRoZXIgYnkgYmlubmluZyBvciBjYXN0aW5nJ1xuICAgIH0sXG4gICAgbWluQ2FyZGluYWxpdHlGb3JCaW46IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgICAgZGVzY3JpcHRpb246ICdtaW5pbXVtIGNhcmRpbmFsaXR5IG9mIGEgZmllbGQgaWYgd2Ugd2VyZSB0byBiaW4nXG4gICAgfSxcbiAgICBvbWl0RG90UGxvdDoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzJ1xuICAgIH0sXG4gICAgb21pdE1lYXN1cmVPbmx5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnT21pdCBhZ2dyZWdhdGlvbiB3aXRoIG1lYXN1cmUocykgb25seSdcbiAgICB9LFxuICAgIG9taXREaW1lbnNpb25Pbmx5OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdPbWl0IGFnZ3JlZ2F0aW9uIHdpdGggZGltZW5zaW9uKHMpIG9ubHknXG4gICAgfSxcbiAgICBhZGRDb3VudEZvckRpbWVuc2lvbk9ubHk6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0FkZCBjb3VudCB3aGVuIHRoZXJlIGFyZSBkaW1lbnNpb24ocykgb25seSdcbiAgICB9LFxuICAgIGFnZ3JMaXN0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHtcbiAgICAgICAgdHlwZTogWydzdHJpbmcnXVxuICAgICAgfSxcbiAgICAgIGRlZmF1bHQ6IFt1bmRlZmluZWQsICdtZWFuJ11cbiAgICB9LFxuICAgIHRpbWVVbml0TGlzdDoge1xuICAgICAgdHlwZTogJ2FycmF5JyxcbiAgICAgIGl0ZW1zOiB7XG4gICAgICAgIHR5cGU6IFsnc3RyaW5nJ11cbiAgICAgIH0sXG4gICAgICBkZWZhdWx0OiBbJ3llYXInXVxuICAgIH0sXG4gICAgY29uc2lzdGVudEF1dG9ROiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246IFwiZ2VuZXJhdGUgc2ltaWxhciBhdXRvIHRyYW5zZm9ybSBmb3IgcXVhbnRcIlxuICAgIH1cbiAgfVxufTtcblxuY29uc3RzLmdlbi5lbmNvZGluZ3MgPSB7XG4gIHR5cGU6ICdvYmplY3QnLFxuICBwcm9wZXJ0aWVzOiB7XG4gICAgbWFya3R5cGVMaXN0OiB7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgaXRlbXM6IHt0eXBlOiAnc3RyaW5nJ30sXG4gICAgICBkZWZhdWx0OiBbJ3BvaW50JywgJ2JhcicsICdsaW5lJywgJ2FyZWEnLCAndGV4dCcsICd0aWNrJ10sIC8vZmlsbGVkX21hcFxuICAgICAgZGVzY3JpcHRpb246ICdhbGxvd2VkIG1hcmt0eXBlcydcbiAgICB9LFxuICAgIGVuY29kaW5nVHlwZUxpc3Q6IHtcbiAgICAgIHR5cGU6ICdhcnJheScsXG4gICAgICBpdGVtczoge3R5cGU6ICdzdHJpbmcnfSxcbiAgICAgIGRlZmF1bHQ6IFsneCcsICd5JywgJ3JvdycsICdjb2wnLCAnc2l6ZScsICdjb2xvcicsICd0ZXh0JywgJ2RldGFpbCddLFxuICAgICAgZGVzY3JpcHRpb246ICdhbGxvd2VkIGVuY29kaW5nIHR5cGVzJ1xuICAgIH0sXG4gICAgbWF4R29vZENhcmRpbmFsaXR5Rm9yRmFjZXRzOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiA1LFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGEgZmllbGQgdG8gYmUgcHV0IG9uIGZhY2V0IChyb3cvY29sKSBlZmZlY3RpdmVseSdcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yRmFjZXRzOiB7XG4gICAgICB0eXBlOiAnaW50ZWdlcicsXG4gICAgICBkZWZhdWx0OiAyMCxcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhIGZpZWxkIHRvIGJlIHB1dCBvbiBmYWNldCAocm93L2NvbCknXG4gICAgfSxcbiAgICBtYXhHb29kQ2FyZGluYWxpdHlGb3JDb2xvcjoge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNyxcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhbiBvcmRpbmFsIGZpZWxkIHRvIGJlIHB1dCBvbiBjb2xvciBlZmZlY3RpdmVseSdcbiAgICB9LFxuICAgIG1heENhcmRpbmFsaXR5Rm9yQ29sb3I6IHtcbiAgICAgIHR5cGU6ICdpbnRlZ2VyJyxcbiAgICAgIGRlZmF1bHQ6IDIwLFxuICAgICAgZGVzY3JpcHRpb246ICdtYXhpbXVtIGNhcmRpbmFsaXR5IG9mIGFuIG9yZGluYWwgZmllbGQgdG8gYmUgcHV0IG9uIGNvbG9yJ1xuICAgIH0sXG4gICAgbWF4Q2FyZGluYWxpdHlGb3JTaGFwZToge1xuICAgICAgdHlwZTogJ2ludGVnZXInLFxuICAgICAgZGVmYXVsdDogNixcbiAgICAgIGRlc2NyaXB0aW9uOiAnbWF4aW11bSBjYXJkaW5hbGl0eSBvZiBhbiBvcmRpbmFsIGZpZWxkIHRvIGJlIHB1dCBvbiBzaGFwZSdcbiAgICB9LFxuICAgIG9taXRUcmFucG9zZTogIHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ0VsaW1pbmF0ZSBhbGwgdHJhbnNwb3NlIGJ5ICgxKSBrZWVwaW5nIGhvcml6b250YWwgZG90IHBsb3Qgb25seSAoMikgZm9yIE94USBjaGFydHMsIGFsd2F5cyBwdXQgTyBvbiBZICgzKSBzaG93IG9ubHkgb25lIER4RCwgTXhNIChjdXJyZW50bHkgc29ydGVkIGJ5IG5hbWUpJ1xuICAgIH0sXG4gICAgb21pdERvdFBsb3Q6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IGZhbHNlLFxuICAgICAgZGVzY3JpcHRpb246ICdyZW1vdmUgYWxsIGRvdCBwbG90cydcbiAgICB9LFxuICAgIG9taXREb3RQbG90V2l0aEV4dHJhRW5jb2Rpbmc6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWUsXG4gICAgICBkZXNjcmlwdGlvbjogJ3JlbW92ZSBhbGwgZG90IHBsb3RzIHdpdGggPjEgZW5jb2RpbmcnXG4gICAgfSxcbiAgICBvbWl0TXVsdGlwbGVSZXRpbmFsRW5jb2RpbmdzOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdvbWl0IHVzaW5nIG11bHRpcGxlIHJldGluYWwgdmFyaWFibGVzIChzaXplLCBjb2xvciwgc2hhcGUpJ1xuICAgIH0sXG4gICAgb21pdE5vblRleHRBZ2dyV2l0aEFsbERpbXNPbkZhY2V0czoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogdHJ1ZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAncmVtb3ZlIGFsbCBhZ2dyZWdhdGVkIGNoYXJ0cyAoZXhjZXB0IHRleHQgdGFibGVzKSB3aXRoIGFsbCBkaW1zIG9uIGZhY2V0cyAocm93LCBjb2wpJ1xuICAgIH0sXG4gICAgb21pdE9uZURpbWVuc2lvbkNvdW50OiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiBmYWxzZSxcbiAgICAgIGRlc2NyaXB0aW9uOiAnb21pdCBvbmUgZGltZW5zaW9uIGNvdW50J1xuICAgIH0sXG4gICAgb21pdFNpemVPbkJhcjoge1xuICAgICAgdHlwZTogJ2Jvb2xlYW4nLFxuICAgICAgZGVmYXVsdDogZmFsc2UsXG4gICAgICBkZXNjcmlwdGlvbjogJ2RvIG5vdCB1c2UgYmFyXFwncyBzaXplJ1xuICAgIH0sXG4gICAgb21pdFN0YWNrZWRBdmVyYWdlOiB7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBkZWZhdWx0OiB0cnVlLFxuICAgICAgZGVzY3JpcHRpb246ICdkbyBub3Qgc3RhY2sgYmFyIGNoYXJ0IHdpdGggYXZlcmFnZSdcbiAgICB9LFxuICAgIGFsd2F5c0dlbmVyYXRlVGFibGVBc0hlYXRtYXA6IHtcbiAgICAgIHR5cGU6ICdib29sZWFuJyxcbiAgICAgIGRlZmF1bHQ6IHRydWVcbiAgICB9XG4gIH1cbn07XG5cblxuXG4iLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgY29uc3RzOiByZXF1aXJlKCcuL2NvbnN0cycpLFxuICBjbHVzdGVyOiByZXF1aXJlKCcuL2NsdXN0ZXIvY2x1c3RlcicpLFxuICBnZW46IHJlcXVpcmUoJy4vZ2VuL2dlbicpLFxuICByYW5rOiByZXF1aXJlKCcuL3JhbmsvcmFuaycpLFxuICB1dGlsOiByZXF1aXJlKCcuL3V0aWwnKSxcbiAgYXV0bzogXCItLCBzdW1cIlxufTtcblxuXG4iLCIndXNlIHN0cmljdCc7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpO1xuXG52YXIgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyk7XG5cbnZhciBBVVRPPScqJztcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5BZ2dyZWdhdGVzO1xuXG5mdW5jdGlvbiBnZW5BZ2dyZWdhdGVzKG91dHB1dCwgZmllbGRzLCBzdGF0cywgb3B0KSB7XG4gIG9wdCA9IHZsLnNjaGVtYS51dGlsLmV4dGVuZChvcHR8fHt9LCBjb25zdHMuZ2VuLmFnZ3JlZ2F0ZXMpO1xuICB2YXIgdGYgPSBuZXcgQXJyYXkoZmllbGRzLmxlbmd0aCk7XG4gIHZhciBoYXNOb3JPID0gdmwuYW55KGZpZWxkcywgZnVuY3Rpb24oZikge1xuICAgIHJldHVybiB2bC5lbmNEZWYuaXNUeXBlcyhmLCBbTiwgT10pO1xuICB9KTtcblxuICBmdW5jdGlvbiBlbWl0KGZpZWxkU2V0KSB7XG4gICAgZmllbGRTZXQgPSB2bC5kdXBsaWNhdGUoZmllbGRTZXQpO1xuICAgIGZpZWxkU2V0LmtleSA9IHZsLmVuY0RlZi5zaG9ydGhhbmRzKGZpZWxkU2V0KTtcbiAgICBvdXRwdXQucHVzaChmaWVsZFNldCk7XG4gIH1cblxuICBmdW5jdGlvbiBjaGVja0FuZFB1c2goKSB7XG4gICAgaWYgKG9wdC5vbWl0TWVhc3VyZU9ubHkgfHwgb3B0Lm9taXREaW1lbnNpb25Pbmx5KSB7XG4gICAgICB2YXIgaGFzTWVhc3VyZSA9IGZhbHNlLCBoYXNEaW1lbnNpb24gPSBmYWxzZSwgaGFzUmF3ID0gZmFsc2U7XG4gICAgICB0Zi5mb3JFYWNoKGZ1bmN0aW9uKGYpIHtcbiAgICAgICAgaWYgKHZsLmVuY0RlZi5pc0RpbWVuc2lvbihmKSkge1xuICAgICAgICAgIGhhc0RpbWVuc2lvbiA9IHRydWU7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgaGFzTWVhc3VyZSA9IHRydWU7XG4gICAgICAgICAgaWYgKCFmLmFnZ3JlZ2F0ZSkgaGFzUmF3ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICBpZiAoIWhhc0RpbWVuc2lvbiAmJiAhaGFzUmF3ICYmIG9wdC5vbWl0TWVhc3VyZU9ubHkpIHJldHVybjtcbiAgICAgIGlmICghaGFzTWVhc3VyZSkge1xuICAgICAgICBpZiAob3B0LmFkZENvdW50Rm9yRGltZW5zaW9uT25seSkge1xuICAgICAgICAgIHRmLnB1c2godmwuZW5jRGVmLmNvdW50KCkpO1xuICAgICAgICAgIGVtaXQodGYpO1xuICAgICAgICAgIHRmLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHQub21pdERpbWVuc2lvbk9ubHkpIHJldHVybjtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG9wdC5vbWl0RG90UGxvdCAmJiB0Zi5sZW5ndGggPT09IDEpIHJldHVybjtcbiAgICBlbWl0KHRmKTtcbiAgfVxuXG4gIGZ1bmN0aW9uIGFzc2lnbkFnZ3JRKGksIGhhc0FnZ3IsIGF1dG9Nb2RlLCBhKSB7XG4gICAgdmFyIGNhbkhhdmVBZ2dyID0gaGFzQWdnciA9PT0gdHJ1ZSB8fCBoYXNBZ2dyID09PSBudWxsLFxuICAgICAgY2FudEhhdmVBZ2dyID0gaGFzQWdnciA9PT0gZmFsc2UgfHwgaGFzQWdnciA9PT0gbnVsbDtcbiAgICBpZiAoYSkge1xuICAgICAgaWYgKGNhbkhhdmVBZ2dyKSB7XG4gICAgICAgIHRmW2ldLmFnZ3JlZ2F0ZSA9IGE7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCB0cnVlLCBhdXRvTW9kZSk7XG4gICAgICAgIGRlbGV0ZSB0ZltpXS5hZ2dyZWdhdGU7XG4gICAgICB9XG4gICAgfSBlbHNlIHsgLy8gaWYoYSA9PT0gdW5kZWZpbmVkKVxuICAgICAgaWYgKGNhbnRIYXZlQWdncikge1xuICAgICAgICBhc3NpZ25GaWVsZChpICsgMSwgZmFsc2UsIGF1dG9Nb2RlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25CaW5RKGksIGhhc0FnZ3IsIGF1dG9Nb2RlKSB7XG4gICAgdGZbaV0uYmluID0gdHJ1ZTtcbiAgICBhc3NpZ25GaWVsZChpICsgMSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgIGRlbGV0ZSB0ZltpXS5iaW47XG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25RKGksIGhhc0FnZ3IsIGF1dG9Nb2RlKSB7XG4gICAgdmFyIGYgPSBmaWVsZHNbaV0sXG4gICAgICBjYW5IYXZlQWdnciA9IGhhc0FnZ3IgPT09IHRydWUgfHwgaGFzQWdnciA9PT0gbnVsbDtcblxuICAgIHRmW2ldID0ge25hbWU6IGYubmFtZSwgdHlwZTogZi50eXBlfTtcblxuICAgIGlmIChmLmFnZ3JlZ2F0ZSA9PT0gJ2NvdW50JykgeyAvLyBpZiBjb3VudCBpcyBpbmNsdWRlZCBpbiB0aGUgc2VsZWN0ZWQgZmllbGRzXG4gICAgICBpZiAoY2FuSGF2ZUFnZ3IpIHtcbiAgICAgICAgdGZbaV0uYWdncmVnYXRlID0gZi5hZ2dyZWdhdGU7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCB0cnVlLCBhdXRvTW9kZSk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChmLl9hZ2dyZWdhdGUpIHtcbiAgICAgIC8vIFRPRE8gc3VwcG9ydCBhcnJheSBvZiBmLl9hZ2dycyB0b29cbiAgICAgIGFzc2lnbkFnZ3JRKGksIGhhc0FnZ3IsIGF1dG9Nb2RlLCBmLl9hZ2dyZWdhdGUpO1xuICAgIH0gZWxzZSBpZiAoZi5fcmF3KSB7XG4gICAgICBhc3NpZ25BZ2dyUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSwgdW5kZWZpbmVkKTtcbiAgICB9IGVsc2UgaWYgKGYuX2Jpbikge1xuICAgICAgYXNzaWduQmluUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdC5hZ2dyTGlzdC5mb3JFYWNoKGZ1bmN0aW9uKGEpIHtcbiAgICAgICAgaWYgKCFvcHQuY29uc2lzdGVudEF1dG9RIHx8IGF1dG9Nb2RlID09PSBBVVRPIHx8IGF1dG9Nb2RlID09PSBhKSB7XG4gICAgICAgICAgYXNzaWduQWdnclEoaSwgaGFzQWdnciwgYSAvKmFzc2lnbiBhdXRvTW9kZSovLCBhKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG5cbiAgICAgIGlmICgoIW9wdC5jb25zaXN0ZW50QXV0b1EgfHwgdmwuaXNpbihhdXRvTW9kZSwgW0FVVE8sICdiaW4nLCAnY2FzdCcsICdhdXRvY2FzdCddKSkgJiYgIWhhc05vck8pIHtcbiAgICAgICAgdmFyIGhpZ2hDYXJkaW5hbGl0eSA9IHZsLmVuY0RlZi5jYXJkaW5hbGl0eShmLCBzdGF0cykgPiBvcHQubWluQ2FyZGluYWxpdHlGb3JCaW47XG5cbiAgICAgICAgdmFyIGlzQXV0byA9IG9wdC5nZW5EaW1RID09PSAnYXV0bycsXG4gICAgICAgICAgZ2VuQmluID0gb3B0LmdlbkRpbVEgID09PSAnYmluJyB8fCAoaXNBdXRvICYmIGhpZ2hDYXJkaW5hbGl0eSksXG4gICAgICAgICAgZ2VuQ2FzdCA9IG9wdC5nZW5EaW1RID09PSAnY2FzdCcgfHwgKGlzQXV0byAmJiAhaGlnaENhcmRpbmFsaXR5KTtcblxuICAgICAgICBpZiAoZ2VuQmluICYmIHZsLmlzaW4oYXV0b01vZGUsIFtBVVRPLCAnYmluJywgJ2F1dG9jYXN0J10pKSB7XG4gICAgICAgICAgYXNzaWduQmluUShpLCBoYXNBZ2dyLCBpc0F1dG8gPyAnYXV0b2Nhc3QnIDogJ2JpbicpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChnZW5DYXN0ICYmIHZsLmlzaW4oYXV0b01vZGUsIFtBVVRPLCAnY2FzdCcsICdhdXRvY2FzdCddKSkge1xuICAgICAgICAgIHRmW2ldLnR5cGUgPSAnTyc7XG4gICAgICAgICAgYXNzaWduRmllbGQoaSArIDEsIGhhc0FnZ3IsIGlzQXV0byA/ICdhdXRvY2FzdCcgOiAnY2FzdCcpO1xuICAgICAgICAgIHRmW2ldLnR5cGUgPSAnUSc7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25UaW1lVW5pdFQoaSwgaGFzQWdnciwgYXV0b01vZGUsIHRpbWVVbml0KSB7XG4gICAgdGZbaV0udGltZVVuaXQgPSB0aW1lVW5pdDtcbiAgICBhc3NpZ25GaWVsZChpKzEsIGhhc0FnZ3IsIGF1dG9Nb2RlKTtcbiAgICBkZWxldGUgdGZbaV0udGltZVVuaXQ7XG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25UKGksIGhhc0FnZ3IsIGF1dG9Nb2RlKSB7XG4gICAgdmFyIGYgPSBmaWVsZHNbaV07XG4gICAgdGZbaV0gPSB7bmFtZTogZi5uYW1lLCB0eXBlOiBmLnR5cGV9O1xuXG4gICAgLy8gVE9ETyBzdXBwb3J0IGFycmF5IG9mIGYuX3RpbWVVbml0c1xuICAgIGlmIChmLl90aW1lVW5pdCkge1xuICAgICAgYXNzaWduVGltZVVuaXRUKGksIGhhc0FnZ3IsIGF1dG9Nb2RlLCBmLl90aW1lVW5pdCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIG9wdC50aW1lVW5pdExpc3QuZm9yRWFjaChmdW5jdGlvbih0aW1lVW5pdCkge1xuICAgICAgICBpZiAodGltZVVuaXQgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIGlmICghaGFzQWdncikgeyAvLyBjYW4ndCBhZ2dyZWdhdGUgb3ZlciByYXcgdGltZVxuICAgICAgICAgICAgYXNzaWduRmllbGQoaSsxLCBmYWxzZSwgYXV0b01vZGUpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICBhc3NpZ25UaW1lVW5pdFQoaSwgaGFzQWdnciwgYXV0b01vZGUsIHRpbWVVbml0KTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gRklYTUUgd2hhdCBpZiB5b3UgYWdncmVnYXRlIHRpbWU/XG4gIH1cblxuICBmdW5jdGlvbiBhc3NpZ25GaWVsZChpLCBoYXNBZ2dyLCBhdXRvTW9kZSkge1xuICAgIGlmIChpID09PSBmaWVsZHMubGVuZ3RoKSB7IC8vIElmIGFsbCBmaWVsZHMgYXJlIGFzc2lnbmVkXG4gICAgICBjaGVja0FuZFB1c2goKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB2YXIgZiA9IGZpZWxkc1tpXTtcbiAgICAvLyBPdGhlcndpc2UsIGFzc2lnbiBpLXRoIGZpZWxkXG4gICAgc3dpdGNoIChmLnR5cGUpIHtcbiAgICAgIC8vVE9ETyBcIkRcIiwgXCJHXCJcbiAgICAgIGNhc2UgUTpcbiAgICAgICAgYXNzaWduUShpLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgICBjYXNlIFQ6XG4gICAgICAgIGFzc2lnblQoaSwgaGFzQWdnciwgYXV0b01vZGUpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgTzpcbiAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgY2FzZSBOOlxuICAgICAgICAvKiBmYWxscyB0aHJvdWdoICovXG4gICAgICBkZWZhdWx0OlxuICAgICAgICB0ZltpXSA9IGY7XG4gICAgICAgIGFzc2lnbkZpZWxkKGkgKyAxLCBoYXNBZ2dyLCBhdXRvTW9kZSk7XG4gICAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuXG4gIHZhciBoYXNBZ2dyID0gb3B0LnRhYmxlVHlwZXMgPT09ICdhZ2dyZWdhdGVkJyA/IHRydWUgOiBvcHQudGFibGVUeXBlcyA9PT0gJ2Rpc2FnZ3JlZ2F0ZWQnID8gZmFsc2UgOiBudWxsO1xuICBhc3NpZ25GaWVsZCgwLCBoYXNBZ2dyLCBBVVRPKTtcblxuICByZXR1cm4gb3V0cHV0O1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmwnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ3ZsJ10gOiBudWxsKSxcbiAgZ2VuRW5jcyA9IHJlcXVpcmUoJy4vZW5jcycpLFxuICBnZXRNYXJrdHlwZXMgPSByZXF1aXJlKCcuL21hcmt0eXBlcycpLFxuICByYW5rID0gcmVxdWlyZSgnLi4vcmFuay9yYW5rJyksXG4gIGNvbnN0cyA9IHJlcXVpcmUoJy4uL2NvbnN0cycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGdlbkVuY29kaW5nc0Zyb21GaWVsZHM7XG5cbmZ1bmN0aW9uIGdlbkVuY29kaW5nc0Zyb21GaWVsZHMob3V0cHV0LCBmaWVsZHMsIHN0YXRzLCBvcHQsIG5lc3RlZCkge1xuICAvLyBvcHQgbXVzdCBiZSBhdWdtZW50ZWQgYmVmb3JlIGJlaW5nIHBhc3NlZCB0byBnZW5FbmNzIG9yIGdldE1hcmt0eXBlc1xuICBvcHQgPSB2bC5zY2hlbWEudXRpbC5leHRlbmQob3B0fHx7fSwgY29uc3RzLmdlbi5lbmNvZGluZ3MpO1xuICB2YXIgZW5jcyA9IGdlbkVuY3MoW10sIGZpZWxkcywgc3RhdHMsIG9wdCk7XG5cbiAgaWYgKG5lc3RlZCkge1xuICAgIHJldHVybiBlbmNzLnJlZHVjZShmdW5jdGlvbihkaWN0LCBlbmMpIHtcbiAgICAgIGRpY3RbZW5jXSA9IGdlbkVuY29kaW5nc0Zyb21FbmNzKFtdLCBlbmMsIHN0YXRzLCBvcHQpO1xuICAgICAgcmV0dXJuIGRpY3Q7XG4gICAgfSwge30pO1xuICB9IGVsc2Uge1xuICAgIHJldHVybiBlbmNzLnJlZHVjZShmdW5jdGlvbihsaXN0LCBlbmMpIHtcbiAgICAgIHJldHVybiBnZW5FbmNvZGluZ3NGcm9tRW5jcyhsaXN0LCBlbmMsIHN0YXRzLCBvcHQpO1xuICAgIH0sIFtdKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbmNvZGluZ3NGcm9tRW5jcyhvdXRwdXQsIGVuYywgc3RhdHMsIG9wdCkge1xuICBnZXRNYXJrdHlwZXMoZW5jLCBzdGF0cywgb3B0KVxuICAgIC5mb3JFYWNoKGZ1bmN0aW9uKG1hcmtUeXBlKSB7XG4gICAgICB2YXIgZSA9IHZsLmR1cGxpY2F0ZSh7XG4gICAgICAgICAgLy8gQ2xvbmUgY29uZmlnICYgZW5jb2RpbmcgdG8gdW5pcXVlIG9iamVjdHNcbiAgICAgICAgICBlbmNvZGluZzogZW5jLFxuICAgICAgICAgIGNvbmZpZzogb3B0LmNvbmZpZ1xuICAgICAgICB9KTtcblxuICAgICAgZS5tYXJrdHlwZSA9IG1hcmtUeXBlO1xuICAgICAgLy8gRGF0YSBvYmplY3QgaXMgdGhlIHNhbWUgYWNyb3NzIGNoYXJ0czogcGFzcyBieSByZWZlcmVuY2VcbiAgICAgIGUuZGF0YSA9IG9wdC5kYXRhO1xuXG4gICAgICB2YXIgZW5jb2RpbmcgPSBmaW5hbFRvdWNoKGUsIHN0YXRzLCBvcHQpO1xuICAgICAgdmFyIHNjb3JlID0gcmFuay5lbmNvZGluZyhlbmNvZGluZywgc3RhdHMsIG9wdCk7XG5cbiAgICAgIGVuY29kaW5nLl9pbmZvID0gc2NvcmU7XG4gICAgICBvdXRwdXQucHVzaChlbmNvZGluZyk7XG4gICAgfSk7XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbi8vRklYTUUgdGhpcyBzaG91bGQgYmUgcmVmYWN0b3JzXG5mdW5jdGlvbiBmaW5hbFRvdWNoKGVuY29kaW5nLCBzdGF0cywgb3B0KSB7XG4gIGlmIChlbmNvZGluZy5tYXJrdHlwZSA9PT0gJ3RleHQnICYmIG9wdC5hbHdheXNHZW5lcmF0ZVRhYmxlQXNIZWF0bWFwKSB7XG4gICAgZW5jb2RpbmcuZW5jb2RpbmcuY29sb3IgPSBlbmNvZGluZy5lbmNvZGluZy50ZXh0O1xuICB9XG5cbiAgLy8gZG9uJ3QgaW5jbHVkZSB6ZXJvIGlmIHN0ZGV2L21lYW4gPCAwLjAxXG4gIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS91d2RhdGEvdmlzcmVjL2lzc3Vlcy82OVxuICB2YXIgZW5jID0gZW5jb2RpbmcuZW5jb2Rpbmc7XG4gIFsneCcsICd5J10uZm9yRWFjaChmdW5jdGlvbihldCkge1xuICAgIHZhciBmaWVsZCA9IGVuY1tldF07XG4gICAgaWYgKGZpZWxkICYmIHZsLmVuY0RlZi5pc01lYXN1cmUoZmllbGQpICYmICF2bC5lbmNEZWYuaXNDb3VudChmaWVsZCkpIHtcbiAgICAgIHZhciBzdGF0ID0gc3RhdHNbZmllbGQubmFtZV07XG4gICAgICBpZiAoc3RhdCAmJiBzdGF0LnN0ZGV2IC8gc3RhdC5tZWFuIDwgMC4wMSkge1xuICAgICAgICBmaWVsZC5zY2FsZSA9IHt6ZXJvOiBmYWxzZX07XG4gICAgICB9XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGVuY29kaW5nO1xufVxuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5yZXF1aXJlKCcuLi9nbG9iYWxzJyk7XG5cbnZhciB2bCA9ICh0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiID8gd2luZG93Wyd2bCddIDogdHlwZW9mIGdsb2JhbCAhPT0gXCJ1bmRlZmluZWRcIiA/IGdsb2JhbFsndmwnXSA6IG51bGwpLFxuICBnZW5NYXJrVHlwZXMgPSByZXF1aXJlKCcuL21hcmt0eXBlcycpLFxuICBpc0RpbWVuc2lvbiA9IHZsLmVuY0RlZi5pc0RpbWVuc2lvbixcbiAgaXNNZWFzdXJlID0gdmwuZW5jRGVmLmlzTWVhc3VyZTtcblxubW9kdWxlLmV4cG9ydHMgPSBnZW5FbmNzO1xuXG4vLyBGSVhNRSByZW1vdmUgZGltZW5zaW9uLCBtZWFzdXJlIGFuZCB1c2UgaW5mb3JtYXRpb24gaW4gdmVnYS1saXRlIGluc3RlYWQhXG52YXIgcnVsZXMgPSB7XG4gIHg6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBtdWx0aXBsZTogdHJ1ZSAvL0ZJWE1FIHNob3VsZCBhbGxvdyBtdWx0aXBsZSBvbmx5IGZvciBRLCBUXG4gIH0sXG4gIHk6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgbWVhc3VyZTogdHJ1ZSxcbiAgICBtdWx0aXBsZTogdHJ1ZSAvL0ZJWE1FIHNob3VsZCBhbGxvdyBtdWx0aXBsZSBvbmx5IGZvciBRLCBUXG4gIH0sXG4gIHJvdzoge1xuICAgIGRpbWVuc2lvbjogdHJ1ZSxcbiAgICBtdWx0aXBsZTogdHJ1ZVxuICB9LFxuICBjb2w6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgbXVsdGlwbGU6IHRydWVcbiAgfSxcbiAgc2hhcGU6IHtcbiAgICBkaW1lbnNpb246IHRydWUsXG4gICAgcnVsZXM6IHNoYXBlUnVsZXNcbiAgfSxcbiAgc2l6ZToge1xuICAgIG1lYXN1cmU6IHRydWUsXG4gICAgcnVsZXM6IHJldGluYWxFbmNSdWxlc1xuICB9LFxuICBjb2xvcjoge1xuICAgIGRpbWVuc2lvbjogdHJ1ZSxcbiAgICBtZWFzdXJlOiB0cnVlLFxuICAgIHJ1bGVzOiBjb2xvclJ1bGVzXG4gIH0sXG4gIHRleHQ6IHtcbiAgICBtZWFzdXJlOiB0cnVlXG4gIH0sXG4gIGRldGFpbDoge1xuICAgIGRpbWVuc2lvbjogdHJ1ZVxuICB9XG4gIC8vZ2VvOiB7XG4gIC8vICBnZW86IHRydWVcbiAgLy99LFxuICAvL2FyYzogeyAvLyBwaWVcbiAgLy9cbiAgLy99XG59O1xuXG5mdW5jdGlvbiByZXRpbmFsRW5jUnVsZXMoZW5jLCBmaWVsZCwgc3RhdHMsIG9wdCkge1xuICBpZiAob3B0Lm9taXRNdWx0aXBsZVJldGluYWxFbmNvZGluZ3MpIHtcbiAgICBpZiAoZW5jLmNvbG9yIHx8IGVuYy5zaXplIHx8IGVuYy5zaGFwZSkgcmV0dXJuIGZhbHNlO1xuICB9XG4gIHJldHVybiB0cnVlO1xufVxuXG5mdW5jdGlvbiBjb2xvclJ1bGVzKGVuYywgZmllbGQsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIXJldGluYWxFbmNSdWxlcyhlbmMsIGZpZWxkLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIHJldHVybiB2bC5lbmNEZWYuaXNNZWFzdXJlKGZpZWxkKSB8fFxuICAgIHZsLmVuY0RlZi5jYXJkaW5hbGl0eShmaWVsZCwgc3RhdHMpIDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckNvbG9yO1xufVxuXG5mdW5jdGlvbiBzaGFwZVJ1bGVzKGVuYywgZmllbGQsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIXJldGluYWxFbmNSdWxlcyhlbmMsIGZpZWxkLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuXG4gIGlmIChmaWVsZC5iaW4gJiYgZmllbGQudHlwZSA9PT0gUSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZmllbGQudGltZVVuaXQgJiYgZmllbGQudHlwZSA9PT0gVCkgcmV0dXJuIGZhbHNlO1xuICByZXR1cm4gdmwuZW5jRGVmLmNhcmRpbmFsaXR5KGZpZWxkLCBzdGF0cykgPD0gb3B0Lm1heENhcmRpbmFsaXR5Rm9yQ29sb3I7XG59XG5cbmZ1bmN0aW9uIGRpbU1lYVRyYW5zcG9zZVJ1bGUoZW5jKSB7XG4gIC8vIGNyZWF0ZSBob3Jpem9udGFsIGhpc3RvZ3JhbSBmb3Igb3JkaW5hbFxuICBpZiAodmwuZW5jRGVmLmlzVHlwZXMoZW5jLnksIFtOLCBPXSkgJiYgaXNNZWFzdXJlKGVuYy54KSkgcmV0dXJuIHRydWU7XG5cbiAgLy8gdmVydGljYWwgaGlzdG9ncmFtIGZvciBRIGFuZCBUXG4gIGlmIChpc01lYXN1cmUoZW5jLnkpICYmICghdmwuZW5jRGVmLmlzVHlwZXMoZW5jLngsIFtOLCBPXSkgJiYgaXNEaW1lbnNpb24oZW5jLngpKSkgcmV0dXJuIHRydWU7XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZW5lcmFsUnVsZXMoZW5jLCBzdGF0cywgb3B0KSB7XG4gIC8vIGVuYy50ZXh0IGlzIG9ubHkgdXNlZCBmb3IgVEVYVCBUQUJMRVxuICBpZiAoZW5jLnRleHQpIHtcbiAgICByZXR1cm4gZ2VuTWFya1R5cGVzLnNhdGlzZnlSdWxlcyhlbmMsIFRFWFQsIHN0YXRzLCBvcHQpO1xuICB9XG5cbiAgLy8gQ0FSVEVTSUFOIFBMT1QgT1IgTUFQXG4gIGlmIChlbmMueCB8fCBlbmMueSB8fCBlbmMuZ2VvIHx8IGVuYy5hcmMpIHtcblxuICAgIGlmIChlbmMucm93IHx8IGVuYy5jb2wpIHsgLy9oYXZlIGZhY2V0KHMpXG5cbiAgICAgIC8vIGRvbid0IHVzZSBmYWNldHMgYmVmb3JlIGZpbGxpbmcgdXAgeCx5XG4gICAgICBpZiAoIWVuYy54IHx8ICFlbmMueSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgICBpZiAob3B0Lm9taXROb25UZXh0QWdncldpdGhBbGxEaW1zT25GYWNldHMpIHtcbiAgICAgICAgLy8gcmVtb3ZlIGFsbCBhZ2dyZWdhdGVkIGNoYXJ0cyB3aXRoIGFsbCBkaW1zIG9uIGZhY2V0cyAocm93LCBjb2wpXG4gICAgICAgIGlmIChnZW5FbmNzLmlzQWdncldpdGhBbGxEaW1PbkZhY2V0cyhlbmMpKSByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGVuYy54ICYmIGVuYy55KSB7XG4gICAgICB2YXIgaXNEaW1YID0gISFpc0RpbWVuc2lvbihlbmMueCksXG4gICAgICAgIGlzRGltWSA9ICEhaXNEaW1lbnNpb24oZW5jLnkpO1xuXG4gICAgICBpZiAoaXNEaW1YICYmIGlzRGltWSAmJiAhdmwuZW5jLmlzQWdncmVnYXRlKGVuYykpIHtcbiAgICAgICAgLy8gRklYTUUgYWN0dWFsbHkgY2hlY2sgaWYgdGhlcmUgd291bGQgYmUgb2NjbHVzaW9uICM5MFxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHQub21pdFRyYW5wb3NlKSB7XG4gICAgICAgIGlmIChpc0RpbVggXiBpc0RpbVkpIHsgLy8gZGltIHggbWVhXG4gICAgICAgICAgaWYgKCFkaW1NZWFUcmFuc3Bvc2VSdWxlKGVuYykpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIGlmIChlbmMueS50eXBlPT09VCB8fCBlbmMueC50eXBlID09PSBUKSB7XG4gICAgICAgICAgaWYgKGVuYy55LnR5cGU9PT1UICYmIGVuYy54LnR5cGUgIT09IFQpIHJldHVybiBmYWxzZTtcbiAgICAgICAgfSBlbHNlIHsgLy8gc2hvdyBvbmx5IG9uZSBPeE8sIFF4UVxuICAgICAgICAgIGlmIChlbmMueC5uYW1lID4gZW5jLnkubmFtZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG5cbiAgICAvLyBET1QgUExPVFNcbiAgICAvLyAvLyBwbG90IHdpdGggb25lIGF4aXMgPSBkb3QgcGxvdFxuICAgIGlmIChvcHQub21pdERvdFBsb3QpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIERvdCBwbG90IHNob3VsZCBhbHdheXMgYmUgaG9yaXpvbnRhbFxuICAgIGlmIChvcHQub21pdFRyYW5wb3NlICYmIGVuYy55KSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCBzaG91bGRuJ3QgaGF2ZSBvdGhlciBlbmNvZGluZ1xuICAgIGlmIChvcHQub21pdERvdFBsb3RXaXRoRXh0cmFFbmNvZGluZyAmJiB2bC5rZXlzKGVuYykubGVuZ3RoID4gMSkgcmV0dXJuIGZhbHNlO1xuXG4gICAgaWYgKG9wdC5vbWl0T25lRGltZW5zaW9uQ291bnQpIHtcbiAgICAgIC8vIG9uZSBkaW1lbnNpb24gXCJjb3VudFwiXG4gICAgaWYgKGVuYy54ICYmIGVuYy54LmFnZ3JlZ2F0ZSA9PSAnY291bnQnICYmICFlbmMueSkgcmV0dXJuIGZhbHNlO1xuICAgIGlmIChlbmMueSAmJiBlbmMueS5hZ2dyZWdhdGUgPT0gJ2NvdW50JyAmJiAhZW5jLngpIHJldHVybiBmYWxzZTtcbiAgICB9XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmdlbkVuY3MuaXNBZ2dyV2l0aEFsbERpbU9uRmFjZXRzID0gZnVuY3Rpb24gKGVuYykge1xuICB2YXIgaGFzQWdnciA9IGZhbHNlLCBoYXNPdGhlck8gPSBmYWxzZTtcbiAgZm9yICh2YXIgZW5jVHlwZSBpbiBlbmMpIHtcbiAgICB2YXIgZmllbGQgPSBlbmNbZW5jVHlwZV07XG4gICAgaWYgKGZpZWxkLmFnZ3JlZ2F0ZSkge1xuICAgICAgaGFzQWdnciA9IHRydWU7XG4gICAgfVxuICAgIGlmICh2bC5lbmNEZWYuaXNEaW1lbnNpb24oZmllbGQpICYmIChlbmNUeXBlICE9PSBST1cgJiYgZW5jVHlwZSAhPT0gQ09MKSkge1xuICAgICAgaGFzT3RoZXJPID0gdHJ1ZTtcbiAgICB9XG4gICAgaWYgKGhhc0FnZ3IgJiYgaGFzT3RoZXJPKSBicmVhaztcbiAgfVxuXG4gIHJldHVybiBoYXNBZ2dyICYmICFoYXNPdGhlck87XG59O1xuXG5cbmZ1bmN0aW9uIGdlbkVuY3MoZW5jcywgZmllbGRzLCBzdGF0cywgb3B0KSB7XG4gIC8vIGdlbmVyYXRlIGEgY29sbGVjdGlvbiB2ZWdhLWxpdGUncyBlbmNcbiAgdmFyIHRtcEVuYyA9IHt9O1xuXG4gIGZ1bmN0aW9uIGFzc2lnbkZpZWxkKGkpIHtcbiAgICAvLyBJZiBhbGwgZmllbGRzIGFyZSBhc3NpZ25lZCwgc2F2ZVxuICAgIGlmIChpID09PSBmaWVsZHMubGVuZ3RoKSB7XG4gICAgICAvLyBhdCB0aGUgbWluaW1hbCBhbGwgY2hhcnQgc2hvdWxkIGhhdmUgeCwgeSwgZ2VvLCB0ZXh0IG9yIGFyY1xuICAgICAgaWYgKGdlbmVyYWxSdWxlcyh0bXBFbmMsIHN0YXRzLCBvcHQpKSB7XG4gICAgICAgIGVuY3MucHVzaCh2bC5kdXBsaWNhdGUodG1wRW5jKSk7XG4gICAgICB9XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gT3RoZXJ3aXNlLCBhc3NpZ24gaS10aCBmaWVsZFxuICAgIHZhciBmaWVsZCA9IGZpZWxkc1tpXTtcbiAgICBmb3IgKHZhciBqIGluIG9wdC5lbmNvZGluZ1R5cGVMaXN0KSB7XG4gICAgICB2YXIgZXQgPSBvcHQuZW5jb2RpbmdUeXBlTGlzdFtqXSxcbiAgICAgICAgaXNEaW0gPSBpc0RpbWVuc2lvbihmaWVsZCk7XG5cbiAgICAgIC8vVE9ETzogc3VwcG9ydCBcIm11bHRpcGxlXCIgYXNzaWdubWVudFxuICAgICAgaWYgKCEoZXQgaW4gdG1wRW5jKSAmJiAvLyBlbmNvZGluZyBub3QgdXNlZFxuICAgICAgICAoKGlzRGltICYmIHJ1bGVzW2V0XS5kaW1lbnNpb24pIHx8ICghaXNEaW0gJiYgcnVsZXNbZXRdLm1lYXN1cmUpKSAmJlxuICAgICAgICAoIXJ1bGVzW2V0XS5ydWxlcyB8fCBydWxlc1tldF0ucnVsZXModG1wRW5jLCBmaWVsZCwgc3RhdHMsIG9wdCkpXG4gICAgICApIHtcbiAgICAgICAgdG1wRW5jW2V0XSA9IGZpZWxkO1xuICAgICAgICBhc3NpZ25GaWVsZChpICsgMSk7XG4gICAgICAgIGRlbGV0ZSB0bXBFbmNbZXRdO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGFzc2lnbkZpZWxkKDApO1xuXG4gIHJldHVybiBlbmNzO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKTtcblxudmFyIGdlbiA9IG1vZHVsZS5leHBvcnRzID0ge1xuICAvLyBkYXRhIHZhcmlhdGlvbnNcbiAgYWdncmVnYXRlczogcmVxdWlyZSgnLi9hZ2dyZWdhdGVzJyksXG4gIHByb2plY3Rpb25zOiByZXF1aXJlKCcuL3Byb2plY3Rpb25zJyksXG4gIC8vIGVuY29kaW5ncyAvIHZpc3VhbCB2YXJpYXRvbnNcbiAgZW5jb2RpbmdzOiByZXF1aXJlKCcuL2VuY29kaW5ncycpLFxuICBlbmNzOiByZXF1aXJlKCcuL2VuY3MnKSxcbiAgbWFya3R5cGVzOiByZXF1aXJlKCcuL21hcmt0eXBlcycpXG59O1xuXG5nZW4uY2hhcnRzID0gZnVuY3Rpb24oZmllbGRzLCBvcHQsIGNmZywgZmxhdCkge1xuICBvcHQgPSB1dGlsLmdlbi5nZXRPcHQob3B0KTtcbiAgZmxhdCA9IGZsYXQgPT09IHVuZGVmaW5lZCA/IHtlbmNvZGluZ3M6IDF9IDogZmxhdDtcblxuICAvLyBUT0RPIGdlbmVyYXRlXG5cbiAgLy8gZ2VuZXJhdGUgcGVybXV0YXRpb24gb2YgZW5jb2RpbmcgbWFwcGluZ3NcbiAgdmFyIGZpZWxkU2V0cyA9IG9wdC5nZW5BZ2dyID8gZ2VuLmFnZ3JlZ2F0ZXMoW10sIGZpZWxkcywgb3B0KSA6IFtmaWVsZHNdLFxuICAgIGVuY3MsIGNoYXJ0cywgbGV2ZWwgPSAwO1xuXG4gIGlmIChmbGF0ID09PSB0cnVlIHx8IChmbGF0ICYmIGZsYXQuYWdncmVnYXRlKSkge1xuICAgIGVuY3MgPSBmaWVsZFNldHMucmVkdWNlKGZ1bmN0aW9uKG91dHB1dCwgZmllbGRzKSB7XG4gICAgICByZXR1cm4gZ2VuLmVuY3Mob3V0cHV0LCBmaWVsZHMsIG9wdCk7XG4gICAgfSwgW10pO1xuICB9IGVsc2Uge1xuICAgIGVuY3MgPSBmaWVsZFNldHMubWFwKGZ1bmN0aW9uKGZpZWxkcykge1xuICAgICAgcmV0dXJuIGdlbi5lbmNzKFtdLCBmaWVsZHMsIG9wdCk7XG4gICAgfSwgdHJ1ZSk7XG4gICAgbGV2ZWwgKz0gMTtcbiAgfVxuXG4gIGlmIChmbGF0ID09PSB0cnVlIHx8IChmbGF0ICYmIGZsYXQuZW5jb2RpbmdzKSkge1xuICAgIGNoYXJ0cyA9IHV0aWwubmVzdGVkUmVkdWNlKGVuY3MsIGZ1bmN0aW9uKG91dHB1dCwgZW5jKSB7XG4gICAgICByZXR1cm4gZ2VuLm1hcmt0eXBlcyhvdXRwdXQsIGVuYywgb3B0LCBjZmcpO1xuICAgIH0sIGxldmVsLCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBjaGFydHMgPSB1dGlsLm5lc3RlZE1hcChlbmNzLCBmdW5jdGlvbihlbmMpIHtcbiAgICAgIHJldHVybiBnZW4ubWFya3R5cGVzKFtdLCBlbmMsIG9wdCwgY2ZnKTtcbiAgICB9LCBsZXZlbCwgdHJ1ZSk7XG4gICAgbGV2ZWwgKz0gMTtcbiAgfVxuICByZXR1cm4gY2hhcnRzO1xufTsiLCJcInVzZSBzdHJpY3RcIjtcblxudmFyIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZsJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2bCddIDogbnVsbCksXG4gIGlzRGltZW5zaW9uID0gdmwuZW5jRGVmLmlzRGltZW5zaW9uLFxuICBpc09yZGluYWxTY2FsZSA9IHZsLmVuY0RlZi5pc09yZGluYWxTY2FsZTtcblxudmFyIHZsbWFya3R5cGVzID0gbW9kdWxlLmV4cG9ydHMgPSBnZXRNYXJrdHlwZXM7XG5cbnZhciBtYXJrc1J1bGUgPSB2bG1hcmt0eXBlcy5ydWxlID0ge1xuICBwb2ludDogIHBvaW50UnVsZSxcbiAgYmFyOiAgICBiYXJSdWxlLFxuICBsaW5lOiAgIGxpbmVSdWxlLFxuICBhcmVhOiAgIGFyZWFSdWxlLCAvLyBhcmVhIGlzIHNpbWlsYXIgdG8gbGluZVxuICB0ZXh0OiAgIHRleHRSdWxlLFxuICB0aWNrOiAgIHRpY2tSdWxlXG59O1xuXG5mdW5jdGlvbiBnZXRNYXJrdHlwZXMoZW5jLCBzdGF0cywgb3B0KSB7XG4gIHJldHVybiBvcHQubWFya3R5cGVMaXN0LmZpbHRlcihmdW5jdGlvbihtYXJrVHlwZSl7XG4gICAgcmV0dXJuIHZsbWFya3R5cGVzLnNhdGlzZnlSdWxlcyhlbmMsIG1hcmtUeXBlLCBzdGF0cywgb3B0KTtcbiAgfSk7XG59XG5cbnZsbWFya3R5cGVzLnNhdGlzZnlSdWxlcyA9IGZ1bmN0aW9uIChlbmMsIG1hcmtUeXBlLCBzdGF0cywgb3B0KSB7XG4gIHZhciBtYXJrID0gdmwuY29tcGlsZXIubWFya3NbbWFya1R5cGVdLFxuICAgIHJlcXMgPSBtYXJrLnJlcXVpcmVkRW5jb2RpbmcsXG4gICAgc3VwcG9ydCA9IG1hcmsuc3VwcG9ydGVkRW5jb2Rpbmc7XG5cbiAgZm9yICh2YXIgaSBpbiByZXFzKSB7IC8vIGFsbCByZXF1aXJlZCBlbmNvZGluZ3MgaW4gZW5jXG4gICAgaWYgKCEocmVxc1tpXSBpbiBlbmMpKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICBmb3IgKHZhciBlbmNUeXBlIGluIGVuYykgeyAvLyBhbGwgZW5jb2RpbmdzIGluIGVuYyBhcmUgc3VwcG9ydGVkXG4gICAgaWYgKCFzdXBwb3J0W2VuY1R5cGVdKSByZXR1cm4gZmFsc2U7XG4gIH1cblxuICByZXR1cm4gIW1hcmtzUnVsZVttYXJrVHlwZV0gfHwgbWFya3NSdWxlW21hcmtUeXBlXShlbmMsIHN0YXRzLCBvcHQpO1xufTtcblxuZnVuY3Rpb24gZmFjZXRSdWxlKGZpZWxkLCBzdGF0cywgb3B0KSB7XG4gIHJldHVybiB2bC5lbmNEZWYuY2FyZGluYWxpdHkoZmllbGQsIHN0YXRzKSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JGYWNldHM7XG59XG5cbmZ1bmN0aW9uIGZhY2V0c1J1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIGlmKGVuYy5yb3cgJiYgIWZhY2V0UnVsZShlbmMucm93LCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuICBpZihlbmMuY29sICYmICFmYWNldFJ1bGUoZW5jLmNvbCwgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHBvaW50UnVsZShlbmMsIHN0YXRzLCBvcHQpIHtcbiAgaWYoIWZhY2V0c1J1bGUoZW5jLCBzdGF0cywgb3B0KSkgcmV0dXJuIGZhbHNlO1xuICBpZiAoZW5jLnggJiYgZW5jLnkpIHtcbiAgICAvLyBoYXZlIGJvdGggeCAmIHkgPT0+IHNjYXR0ZXIgcGxvdCAvIGJ1YmJsZSBwbG90XG5cbiAgICB2YXIgeElzRGltID0gaXNEaW1lbnNpb24oZW5jLngpLFxuICAgICAgeUlzRGltID0gaXNEaW1lbnNpb24oZW5jLnkpO1xuXG4gICAgLy8gRm9yIE94T1xuICAgIGlmICh4SXNEaW0gJiYgeUlzRGltKSB7XG4gICAgICAvLyBzaGFwZSBkb2Vzbid0IHdvcmsgd2l0aCBib3RoIHgsIHkgYXMgb3JkaW5hbFxuICAgICAgaWYgKGVuYy5zaGFwZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG5cbiAgICAgIC8vIFRPRE8oa2FuaXR3KTogY2hlY2sgdGhhdCB0aGVyZSBpcyBxdWFudCBhdCBsZWFzdCAuLi5cbiAgICAgIGlmIChlbmMuY29sb3IgJiYgaXNEaW1lbnNpb24oZW5jLmNvbG9yKSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgfVxuXG4gIH0gZWxzZSB7IC8vIHBsb3Qgd2l0aCBvbmUgYXhpcyA9IGRvdCBwbG90XG4gICAgaWYgKG9wdC5vbWl0RG90UGxvdCkgcmV0dXJuIGZhbHNlO1xuXG4gICAgLy8gRG90IHBsb3Qgc2hvdWxkIGFsd2F5cyBiZSBob3Jpem9udGFsXG4gICAgaWYgKG9wdC5vbWl0VHJhbnBvc2UgJiYgZW5jLnkpIHJldHVybiBmYWxzZTtcblxuICAgIC8vIGRvdCBwbG90IHNob3VsZG4ndCBoYXZlIG90aGVyIGVuY29kaW5nXG4gICAgaWYgKG9wdC5vbWl0RG90UGxvdFdpdGhFeHRyYUVuY29kaW5nICYmIHZsLmtleXMoZW5jKS5sZW5ndGggPiAxKSByZXR1cm4gZmFsc2U7XG5cbiAgICAvLyBkb3QgcGxvdCB3aXRoIHNoYXBlIGlzIG5vbi1zZW5zZVxuICAgIGlmIChlbmMuc2hhcGUpIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gdGlja1J1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgaWYgKGVuYy54IHx8IGVuYy55KSB7XG4gICAgaWYodmwuZW5jLmlzQWdncmVnYXRlKGVuYykpIHJldHVybiBmYWxzZTtcblxuICAgIHZhciB4SXNEaW0gPSBpc0RpbWVuc2lvbihlbmMueCksXG4gICAgICB5SXNEaW0gPSBpc0RpbWVuc2lvbihlbmMueSk7XG5cbiAgICByZXR1cm4gKCF4SXNEaW0gJiYgKCFlbmMueSB8fCBpc09yZGluYWxTY2FsZShlbmMueSkpKSB8fFxuICAgICAgKCF5SXNEaW0gJiYgKCFlbmMueCB8fCBpc09yZGluYWxTY2FsZShlbmMueCkpKTtcbiAgfVxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGJhclJ1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIGlmKCFmYWNldHNSdWxlKGVuYywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICAvLyBiYXIgcmVxdWlyZXMgYXQgbGVhc3QgeCBvciB5XG4gIGlmICghZW5jLnggJiYgIWVuYy55KSByZXR1cm4gZmFsc2U7XG5cbiAgaWYgKG9wdC5vbWl0U2l6ZU9uQmFyICYmIGVuYy5zaXplICE9PSB1bmRlZmluZWQpIHJldHVybiBmYWxzZTtcblxuICAvLyBGSVhNRSBhY3R1YWxseSBjaGVjayBpZiB0aGVyZSB3b3VsZCBiZSBvY2NsdXNpb24gIzkwXG4gIC8vIG5lZWQgdG8gYWdncmVnYXRlIG9uIGVpdGhlciB4IG9yIHlcbiAgdmFyIGFnZ0VpdGhlclhvclkgPVxuICAgICghZW5jLnggfHwgZW5jLnguYWdncmVnYXRlID09PSB1bmRlZmluZWQpIF5cbiAgICAoIWVuYy55IHx8IGVuYy55LmFnZ3JlZ2F0ZSA9PT0gdW5kZWZpbmVkKTtcblxuXG4gIGlmIChhZ2dFaXRoZXJYb3JZKSB7XG4gICAgdmFyIGVpdGhlclhvcllpc0RpbU9yTnVsbCA9XG4gICAgICAoIWVuYy54IHx8IGlzRGltZW5zaW9uKGVuYy54KSkgXlxuICAgICAgKCFlbmMueSB8fCBpc0RpbWVuc2lvbihlbmMueSkpO1xuXG4gICAgaWYgKGVpdGhlclhvcllpc0RpbU9yTnVsbCkge1xuICAgICAgdmFyIGFnZ3JlZ2F0ZSA9IGVuYy54LmFnZ3JlZ2F0ZSB8fCBlbmMueS5hZ2dyZWdhdGU7XG4gICAgICByZXR1cm4gIShvcHQub21pdFN0YWNrZWRBdmVyYWdlICYmIGFnZ3JlZ2F0ZSA9PT0nbWVhbicgJiYgZW5jLmNvbG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGxpbmVSdWxlKGVuYywgc3RhdHMsIG9wdCkge1xuICBpZighZmFjZXRzUnVsZShlbmMsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG5cbiAgLy8gVE9ETyhrYW5pdHcpOiBhZGQgb21pdFZlcnRpY2FsTGluZSBhcyBjb25maWdcblxuICAvLyBGSVhNRSB0cnVseSBvcmRpbmFsIGRhdGEgaXMgZmluZSBoZXJlIHRvby5cbiAgLy8gTGluZSBjaGFydCBzaG91bGQgYmUgb25seSBob3Jpem9udGFsXG4gIC8vIGFuZCB1c2Ugb25seSB0ZW1wb3JhbCBkYXRhXG4gIHJldHVybiBlbmMueC50eXBlID09ICdUJyAmJiBlbmMueC50aW1lVW5pdCAmJiBlbmMueS50eXBlID09ICdRJyAmJiBlbmMueS5hZ2dyZWdhdGU7XG59XG5cbmZ1bmN0aW9uIGFyZWFSdWxlKGVuYywgc3RhdHMsIG9wdCkge1xuICBpZighZmFjZXRzUnVsZShlbmMsIHN0YXRzLCBvcHQpKSByZXR1cm4gZmFsc2U7XG5cbiAgaWYoIWxpbmVSdWxlKGVuYywgc3RhdHMsIG9wdCkpIHJldHVybiBmYWxzZTtcblxuICByZXR1cm4gIShvcHQub21pdFN0YWNrZWRBdmVyYWdlICYmIGVuYy55LmFnZ3JlZ2F0ZSA9PT0nbWVhbicgJiYgZW5jLmNvbG9yKTtcbn1cblxuZnVuY3Rpb24gdGV4dFJ1bGUoZW5jLCBzdGF0cywgb3B0KSB7XG4gIC8vIGF0IGxlYXN0IG11c3QgaGF2ZSByb3cgb3IgY29sIGFuZCBhZ2dyZWdhdGVkIHRleHQgdmFsdWVzXG4gIHJldHVybiAoZW5jLnJvdyB8fCBlbmMuY29sKSAmJiBlbmMudGV4dCAmJiBlbmMudGV4dC5hZ2dyZWdhdGUgJiYgIWVuYy54ICYmICFlbmMueSAmJiAhZW5jLnNpemUgJiZcbiAgICAoIW9wdC5hbHdheXNHZW5lcmF0ZVRhYmxlQXNIZWF0bWFwIHx8ICFlbmMuY29sb3IpO1xufVxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbCA9IHJlcXVpcmUoJy4uL3V0aWwnKSxcbiAgY29uc3RzID0gcmVxdWlyZSgnLi4vY29uc3RzJyksXG4gIHZsID0gKHR5cGVvZiB3aW5kb3cgIT09IFwidW5kZWZpbmVkXCIgPyB3aW5kb3dbJ3ZsJ10gOiB0eXBlb2YgZ2xvYmFsICE9PSBcInVuZGVmaW5lZFwiID8gZ2xvYmFsWyd2bCddIDogbnVsbCksXG4gIGlzRGltZW5zaW9uID0gdmwuZW5jRGVmLmlzRGltZW5zaW9uO1xuXG5tb2R1bGUuZXhwb3J0cyA9IHByb2plY3Rpb25zO1xuXG4vLyBUT0RPIHN1cHBvcnQgb3RoZXIgbW9kZSBvZiBwcm9qZWN0aW9ucyBnZW5lcmF0aW9uXG4vLyBwb3dlcnNldCwgY2hvb3NlSywgY2hvb3NlS29yTGVzcyBhcmUgYWxyZWFkeSBpbmNsdWRlZCBpbiB0aGUgdXRpbFxuXG4vKipcbiAqIGZpZWxkc1xuICogQHBhcmFtICB7W3R5cGVdfSBmaWVsZHMgYXJyYXkgb2YgZmllbGRzIGFuZCBxdWVyeSBpbmZvcm1hdGlvblxuICogQHJldHVybiB7W3R5cGVdfSAgICAgICAgW2Rlc2NyaXB0aW9uXVxuICovXG5mdW5jdGlvbiBwcm9qZWN0aW9ucyhmaWVsZHMsIHN0YXRzLCBvcHQpIHtcbiAgb3B0ID0gdmwuc2NoZW1hLnV0aWwuZXh0ZW5kKG9wdHx8e30sIGNvbnN0cy5nZW4ucHJvamVjdGlvbnMpO1xuXG4gIC8vIEZpcnN0IGNhdGVnb3JpemUgZmllbGQsIHNlbGVjdGVkLCBmaWVsZHNUb0FkZCwgYW5kIHNhdmUgaW5kaWNlc1xuICB2YXIgc2VsZWN0ZWQgPSBbXSwgZmllbGRzVG9BZGQgPSBbXSwgZmllbGRTZXRzID0gW10sXG4gICAgaGFzU2VsZWN0ZWREaW1lbnNpb24gPSBmYWxzZSxcbiAgICBoYXNTZWxlY3RlZE1lYXN1cmUgPSBmYWxzZSxcbiAgICBpbmRpY2VzID0ge307XG5cbiAgZmllbGRzLmZvckVhY2goZnVuY3Rpb24oZmllbGQsIGluZGV4KXtcbiAgICAvL3NhdmUgaW5kaWNlcyBmb3Igc3RhYmxlIHNvcnQgbGF0ZXJcbiAgICBpbmRpY2VzW2ZpZWxkLm5hbWVdID0gaW5kZXg7XG5cbiAgICBpZiAoZmllbGQuc2VsZWN0ZWQpIHtcbiAgICAgIHNlbGVjdGVkLnB1c2goZmllbGQpO1xuICAgICAgaWYgKGlzRGltZW5zaW9uKGZpZWxkKSB8fCBmaWVsZC50eXBlID09PSdUJykgeyAvLyBGSVhNRSAvIEhBQ0tcbiAgICAgICAgaGFzU2VsZWN0ZWREaW1lbnNpb24gPSB0cnVlO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGFzU2VsZWN0ZWRNZWFzdXJlID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGZpZWxkLnNlbGVjdGVkICE9PSBmYWxzZSAmJiAhdmwuZW5jRGVmLmlzQ291bnQoZmllbGQpKSB7XG4gICAgICBpZiAodmwuZW5jRGVmLmlzRGltZW5zaW9uKGZpZWxkKSAmJlxuICAgICAgICAgICFvcHQubWF4Q2FyZGluYWxpdHlGb3JBdXRvQWRkT3JkaW5hbCAmJlxuICAgICAgICAgIHZsLmVuY0RlZi5jYXJkaW5hbGl0eShmaWVsZCwgc3RhdHMsIDE1KSA+IG9wdC5tYXhDYXJkaW5hbGl0eUZvckF1dG9BZGRPcmRpbmFsXG4gICAgICAgICkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBmaWVsZHNUb0FkZC5wdXNoKGZpZWxkKTtcbiAgICB9XG4gIH0pO1xuXG4gIGZpZWxkc1RvQWRkLnNvcnQoY29tcGFyZUZpZWxkc1RvQWRkKGhhc1NlbGVjdGVkRGltZW5zaW9uLCBoYXNTZWxlY3RlZE1lYXN1cmUsIGluZGljZXMpKTtcblxuICB2YXIgc2V0c1RvQWRkID0gdXRpbC5jaG9vc2VLb3JMZXNzKGZpZWxkc1RvQWRkLCAxKTtcblxuICBzZXRzVG9BZGQuZm9yRWFjaChmdW5jdGlvbihzZXRUb0FkZCkge1xuICAgIHZhciBmaWVsZFNldCA9IHNlbGVjdGVkLmNvbmNhdChzZXRUb0FkZCk7XG4gICAgaWYgKGZpZWxkU2V0Lmxlbmd0aCA+IDApIHtcbiAgICAgIGlmIChvcHQub21pdERvdFBsb3QgJiYgZmllbGRTZXQubGVuZ3RoID09PSAxKSByZXR1cm47XG4gICAgICBmaWVsZFNldHMucHVzaChmaWVsZFNldCk7XG4gICAgfVxuICB9KTtcblxuICBmaWVsZFNldHMuZm9yRWFjaChmdW5jdGlvbihmaWVsZFNldCkge1xuICAgICAgLy8gYWx3YXlzIGFwcGVuZCBwcm9qZWN0aW9uJ3Mga2V5IHRvIGVhY2ggcHJvamVjdGlvbiByZXR1cm5lZCwgZDMgc3R5bGUuXG4gICAgZmllbGRTZXQua2V5ID0gcHJvamVjdGlvbnMua2V5KGZpZWxkU2V0KTtcbiAgfSk7XG5cbiAgcmV0dXJuIGZpZWxkU2V0cztcbn1cblxudmFyIHR5cGVJc01lYXN1cmVTY29yZSA9IHtcbiAgTjogMCxcbiAgTzogMCxcbiAgVDogMixcbiAgUTogM1xufTtcblxuZnVuY3Rpb24gY29tcGFyZUZpZWxkc1RvQWRkKGhhc1NlbGVjdGVkRGltZW5zaW9uLCBoYXNTZWxlY3RlZE1lYXN1cmUsIGluZGljZXMpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uKGEsIGIpe1xuICAgIC8vIHNvcnQgYnkgdHlwZSBvZiB0aGUgZGF0YVxuICAgIGlmIChhLnR5cGUgIT09IGIudHlwZSkge1xuICAgICAgaWYgKCFoYXNTZWxlY3RlZERpbWVuc2lvbikge1xuICAgICAgICByZXR1cm4gdHlwZUlzTWVhc3VyZVNjb3JlW2EudHlwZV0gLSB0eXBlSXNNZWFzdXJlU2NvcmVbYi50eXBlXTtcbiAgICAgIH0gZWxzZSB7IC8vaWYgKCFoYXNTZWxlY3RlZE1lYXN1cmUpIHtcbiAgICAgICAgcmV0dXJuIHR5cGVJc01lYXN1cmVTY29yZVtiLnR5cGVdIC0gdHlwZUlzTWVhc3VyZVNjb3JlW2EudHlwZV07XG4gICAgICB9XG4gICAgfVxuICAgIC8vbWFrZSB0aGUgc29ydCBzdGFibGVcbiAgICByZXR1cm4gaW5kaWNlc1thLm5hbWVdIC0gaW5kaWNlc1tiLm5hbWVdO1xuICB9O1xufVxuXG5wcm9qZWN0aW9ucy5rZXkgPSBmdW5jdGlvbihwcm9qZWN0aW9uKSB7XG4gIHJldHVybiBwcm9qZWN0aW9uLm1hcChmdW5jdGlvbihmaWVsZCkge1xuICAgIHJldHVybiB2bC5lbmNEZWYuaXNDb3VudChmaWVsZCkgPyAnY291bnQnIDogZmllbGQubmFtZTtcbiAgfSkuam9pbignLCcpO1xufTtcblxuIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZyA9IGdsb2JhbCB8fCB3aW5kb3c7XG5cbnJlcXVpcmUoJ3ZlZ2EtbGl0ZS9zcmMvZ2xvYmFscycpO1xuXG5nLkNIQVJUX1RZUEVTID0ge1xuICBUQUJMRTogJ1RBQkxFJyxcbiAgQkFSOiAnQkFSJyxcbiAgUExPVDogJ1BMT1QnLFxuICBMSU5FOiAnTElORScsXG4gIEFSRUE6ICdBUkVBJyxcbiAgTUFQOiAnTUFQJyxcbiAgSElTVE9HUkFNOiAnSElTVE9HUkFNJ1xufTtcblxuZy5BTllfREFUQV9UWVBFUyA9ICgxIDw8IDQpIC0gMTsiLCJtb2R1bGUuZXhwb3J0cyA9IHtcbiAgZW5jb2Rpbmc6IHJlcXVpcmUoJy4vcmFua0VuY29kaW5ncycpXG59O1xuXG5cbiIsIid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnLi4vZ2xvYmFscycpO1xuXG52YXIgdmwgPSAodHlwZW9mIHdpbmRvdyAhPT0gXCJ1bmRlZmluZWRcIiA/IHdpbmRvd1sndmwnXSA6IHR5cGVvZiBnbG9iYWwgIT09IFwidW5kZWZpbmVkXCIgPyBnbG9iYWxbJ3ZsJ10gOiBudWxsKSxcbiAgaXNEaW1lbnNpb24gPSB2bC5lbmNEZWYuaXNEaW1lbnNpb247XG5cbm1vZHVsZS5leHBvcnRzID0gcmFua0VuY29kaW5ncztcblxuLy8gYmFkIHNjb3JlIG5vdCBzcGVjaWZpZWQgaW4gdGhlIHRhYmxlIGFib3ZlXG52YXIgVU5VU0VEX1BPU0lUSU9OID0gMC41O1xuXG52YXIgTUFSS19TQ09SRSA9IHtcbiAgbGluZTogMC45OSxcbiAgYXJlYTogMC45OCxcbiAgYmFyOiAwLjk3LFxuICB0aWNrOiAwLjk2LFxuICBwb2ludDogMC45NSxcbiAgY2lyY2xlOiAwLjk0LFxuICBzcXVhcmU6IDAuOTQsXG4gIHRleHQ6IDAuOFxufTtcblxuZnVuY3Rpb24gcmFua0VuY29kaW5ncyhlbmNvZGluZywgc3RhdHMsIG9wdCwgc2VsZWN0ZWQpIHtcbiAgdmFyIGZlYXR1cmVzID0gW10sXG4gICAgZW5jVHlwZXMgPSB2bC5rZXlzKGVuY29kaW5nLmVuY29kaW5nKSxcbiAgICBtYXJrdHlwZSA9IGVuY29kaW5nLm1hcmt0eXBlLFxuICAgIGVuYyA9IGVuY29kaW5nLmVuY29kaW5nO1xuXG4gIHZhciBlbmNvZGluZ01hcHBpbmdCeUZpZWxkID0gdmwuZW5jLnJlZHVjZShlbmNvZGluZy5lbmNvZGluZywgZnVuY3Rpb24obywgZmllbGQsIGVuY1R5cGUpIHtcbiAgICB2YXIga2V5ID0gdmwuZW5jRGVmLnNob3J0aGFuZChmaWVsZCk7XG4gICAgdmFyIG1hcHBpbmdzID0gb1trZXldID0gb1trZXldIHx8IFtdO1xuICAgIG1hcHBpbmdzLnB1c2goe2VuY1R5cGU6IGVuY1R5cGUsIGZpZWxkOiBmaWVsZH0pO1xuICAgIHJldHVybiBvO1xuICB9LCB7fSk7XG5cbiAgLy8gZGF0YSAtIGVuY29kaW5nIG1hcHBpbmcgc2NvcmVcbiAgdmwuZm9yRWFjaChlbmNvZGluZ01hcHBpbmdCeUZpZWxkLCBmdW5jdGlvbihtYXBwaW5ncykge1xuICAgIHZhciByZWFzb25zID0gbWFwcGluZ3MubWFwKGZ1bmN0aW9uKG0pIHtcbiAgICAgICAgcmV0dXJuIG0uZW5jVHlwZSArIHZsLnNob3J0aGFuZC5hc3NpZ24gKyB2bC5lbmNEZWYuc2hvcnRoYW5kKG0uZmllbGQpICtcbiAgICAgICAgICAnICcgKyAoc2VsZWN0ZWQgJiYgc2VsZWN0ZWRbbS5maWVsZC5uYW1lXSA/ICdbeF0nIDogJ1sgXScpO1xuICAgICAgfSksXG4gICAgICBzY29yZXMgPSBtYXBwaW5ncy5tYXAoZnVuY3Rpb24obSkge1xuICAgICAgICB2YXIgcm9sZSA9IHZsLmVuY0RlZi5pc0RpbWVuc2lvbihtLmZpZWxkKSA/ICdkaW1lbnNpb24nIDogJ21lYXN1cmUnO1xuXG4gICAgICAgIHZhciBzY29yZSA9IHJhbmtFbmNvZGluZ3Muc2NvcmVbcm9sZV0obS5maWVsZCwgbS5lbmNUeXBlLCBlbmNvZGluZy5tYXJrdHlwZSwgc3RhdHMsIG9wdCk7XG5cbiAgICAgICAgcmV0dXJuICFzZWxlY3RlZCB8fCBzZWxlY3RlZFttLmZpZWxkLm5hbWVdID8gc2NvcmUgOiBNYXRoLnBvdyhzY29yZSwgMC4xMjUpO1xuICAgICAgfSk7XG5cbiAgICBmZWF0dXJlcy5wdXNoKHtcbiAgICAgIHJlYXNvbjogcmVhc29ucy5qb2luKFwiIHwgXCIpLFxuICAgICAgc2NvcmU6IE1hdGgubWF4LmFwcGx5KG51bGwsIHNjb3JlcylcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gcGxvdCB0eXBlXG4gIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkge1xuICAgIC8vIFRPRE9cbiAgfSBlbHNlIHtcbiAgICBpZiAoZW5jLnggJiYgZW5jLnkpIHtcbiAgICAgIGlmIChpc0RpbWVuc2lvbihlbmMueCkgXiBpc0RpbWVuc2lvbihlbmMueSkpIHtcbiAgICAgICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICAgICAgcmVhc29uOiAnT3hRIHBsb3QnLFxuICAgICAgICAgIHNjb3JlOiAwLjhcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gcGVuYWxpemUgbm90IHVzaW5nIHBvc2l0aW9uYWwgb25seSBwZW5hbGl6ZSBmb3Igbm9uLXRleHRcbiAgaWYgKGVuY1R5cGVzLmxlbmd0aCA+IDEgJiYgbWFya3R5cGUgIT09IFRFWFQpIHtcbiAgICBpZiAoKCFlbmMueCB8fCAhZW5jLnkpICYmICFlbmMuZ2VvICYmICFlbmMudGV4dCkge1xuICAgICAgZmVhdHVyZXMucHVzaCh7XG4gICAgICAgIHJlYXNvbjogJ3VudXNlZCBwb3NpdGlvbicsXG4gICAgICAgIHNjb3JlOiBVTlVTRURfUE9TSVRJT05cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIC8vIG1hcmsgdHlwZSBzY29yZVxuICBmZWF0dXJlcy5wdXNoKHtcbiAgICByZWFzb246ICdtYXJrdHlwZT0nK21hcmt0eXBlLFxuICAgIHNjb3JlOiBNQVJLX1NDT1JFW21hcmt0eXBlXVxuICB9KTtcblxuICByZXR1cm4ge1xuICAgIHNjb3JlOiBmZWF0dXJlcy5yZWR1Y2UoZnVuY3Rpb24ocCwgZikge1xuICAgICAgcmV0dXJuIHAgKiBmLnNjb3JlO1xuICAgIH0sIDEpLFxuICAgIGZlYXR1cmVzOiBmZWF0dXJlc1xuICB9O1xufVxuXG5cbnZhciBEID0ge30sIE0gPSB7fSwgQkFEID0gMC4xLCBURVJSSUJMRSA9IDAuMDE7XG5cbkQubWlub3IgPSAwLjAxO1xuRC5wb3MgPSAxO1xuRC5ZX1QgPSAwLjg7XG5ELmZhY2V0X3RleHQgPSAxO1xuRC5mYWNldF9nb29kID0gMC42NzU7IC8vIDwgY29sb3Jfb2ssID4gY29sb3JfYmFkXG5ELmZhY2V0X29rID0gMC41NTtcbkQuZmFjZXRfYmFkID0gMC40O1xuRC5jb2xvcl9nb29kID0gMC43O1xuRC5jb2xvcl9vayA9IDAuNjU7IC8vID4gTS5TaXplXG5ELmNvbG9yX2JhZCA9IDAuMztcbkQuY29sb3Jfc3RhY2sgPSAwLjY7XG5ELnNoYXBlID0gMC42O1xuRC5kZXRhaWwgPSAwLjU7XG5ELmJhZCA9IEJBRDtcbkQudGVycmlibGUgPSBURVJSSUJMRTtcblxuTS5wb3MgPSAxO1xuTS5zaXplID0gMC42O1xuTS5jb2xvciA9IDAuNTtcbk0udGV4dCA9IDAuNDtcbk0uYmFkID0gQkFEO1xuTS50ZXJyaWJsZSA9IFRFUlJJQkxFO1xuXG5yYW5rRW5jb2RpbmdzLmRpbWVuc2lvblNjb3JlID0gZnVuY3Rpb24gKGZpZWxkLCBlbmNUeXBlLCBtYXJrdHlwZSwgc3RhdHMsIG9wdCl7XG4gIHZhciBjYXJkaW5hbGl0eSA9IHZsLmVuY0RlZi5jYXJkaW5hbGl0eShmaWVsZCwgc3RhdHMpO1xuICBzd2l0Y2ggKGVuY1R5cGUpIHtcbiAgICBjYXNlIFg6XG4gICAgICBpZiAodmwuZW5jRGVmLmlzVHlwZXMoZmllbGQsIFtOLCBPXSkpICByZXR1cm4gRC5wb3MgLSBELm1pbm9yO1xuICAgICAgcmV0dXJuIEQucG9zO1xuXG4gICAgY2FzZSBZOlxuICAgICAgaWYgKHZsLmVuY0RlZi5pc1R5cGVzKGZpZWxkLCBbTiwgT10pKSByZXR1cm4gRC5wb3MgLSBELm1pbm9yOyAvL3ByZWZlciBvcmRpbmFsIG9uIHlcbiAgICAgIGlmKGZpZWxkLnR5cGUgPT09IFQpIHJldHVybiBELllfVDsgLy8gdGltZSBzaG91bGQgbm90IGJlIG9uIFlcbiAgICAgIHJldHVybiBELnBvcyAtIEQubWlub3I7XG5cbiAgICBjYXNlIENPTDpcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkgcmV0dXJuIEQuZmFjZXRfdGV4dDtcbiAgICAgIC8vcHJlZmVyIGNvbHVtbiBvdmVyIHJvdyBkdWUgdG8gc2Nyb2xsaW5nIGlzc3Vlc1xuICAgICAgcmV0dXJuIGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhHb29kQ2FyZGluYWxpdHlGb3JGYWNldHMgPyBELmZhY2V0X2dvb2QgOlxuICAgICAgICBjYXJkaW5hbGl0eSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JGYWNldHMgPyBELmZhY2V0X29rIDogRC5mYWNldF9iYWQ7XG5cbiAgICBjYXNlIFJPVzpcbiAgICAgIGlmIChtYXJrdHlwZSA9PT0gVEVYVCkgcmV0dXJuIEQuZmFjZXRfdGV4dDtcbiAgICAgIHJldHVybiAoY2FyZGluYWxpdHkgPD0gb3B0Lm1heEdvb2RDYXJkaW5hbGl0eUZvckZhY2V0cyA/IEQuZmFjZXRfZ29vZCA6XG4gICAgICAgIGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvckZhY2V0cyA/IEQuZmFjZXRfb2sgOiBELmZhY2V0X2JhZCkgLSBELm1pbm9yO1xuXG4gICAgY2FzZSBDT0xPUjpcbiAgICAgIHZhciBoYXNPcmRlciA9IChmaWVsZC5iaW4gJiYgZmllbGQudHlwZT09PVEpIHx8IChmaWVsZC50aW1lVW5pdCAmJiBmaWVsZC50eXBlPT09VCk7XG5cbiAgICAgIC8vRklYTUUgYWRkIHN0YWNraW5nIG9wdGlvbiBvbmNlIHdlIGhhdmUgY29udHJvbCAuLlxuICAgICAgdmFyIGlzU3RhY2tlZCA9IG1hcmt0eXBlID09PSAnYmFyJyB8fCBtYXJrdHlwZSA9PT0gJ2FyZWEnO1xuXG4gICAgICAvLyB0cnVlIG9yZGluYWwgb24gY29sb3IgaXMgY3VycmVudGx5IEJBRCAodW50aWwgd2UgaGF2ZSBnb29kIG9yZGluYWwgY29sb3Igc2NhbGUgc3VwcG9ydClcbiAgICAgIGlmIChoYXNPcmRlcikgcmV0dXJuIEQuY29sb3JfYmFkO1xuXG4gICAgICAvL3N0YWNraW5nIGdldHMgbG93ZXIgc2NvcmVcbiAgICAgIGlmIChpc1N0YWNrZWQpIHJldHVybiBELmNvbG9yX3N0YWNrO1xuXG4gICAgICByZXR1cm4gY2FyZGluYWxpdHkgPD0gb3B0Lm1heEdvb2RDYXJkaW5hbGl0eUZvckNvbG9yID8gRC5jb2xvcl9nb29kOiBjYXJkaW5hbGl0eSA8PSBvcHQubWF4Q2FyZGluYWxpdHlGb3JDb2xvciA/IEQuY29sb3Jfb2sgOiBELmNvbG9yX2JhZDtcbiAgICBjYXNlIFNIQVBFOlxuICAgICAgcmV0dXJuIGNhcmRpbmFsaXR5IDw9IG9wdC5tYXhDYXJkaW5hbGl0eUZvclNoYXBlID8gRC5zaGFwZSA6IFRFUlJJQkxFO1xuICAgIGNhc2UgREVUQUlMOlxuICAgICAgcmV0dXJuIEQuZGV0YWlsO1xuICB9XG4gIHJldHVybiBURVJSSUJMRTtcbn07XG5cbnJhbmtFbmNvZGluZ3MuZGltZW5zaW9uU2NvcmUuY29uc3RzID0gRDtcblxucmFua0VuY29kaW5ncy5tZWFzdXJlU2NvcmUgPSBmdW5jdGlvbiAoZmllbGQsIGVuY1R5cGUsIG1hcmt0eXBlLCBzdGF0cywgb3B0KSB7XG4gIC8vIGpzaGludCB1bnVzZWQ6ZmFsc2VcbiAgc3dpdGNoIChlbmNUeXBlKXtcbiAgICBjYXNlIFg6IHJldHVybiBNLnBvcztcbiAgICBjYXNlIFk6IHJldHVybiBNLnBvcztcbiAgICBjYXNlIFNJWkU6XG4gICAgICBpZiAobWFya3R5cGUgPT09ICdiYXInKSByZXR1cm4gQkFEOyAvL3NpemUgb2YgYmFyIGlzIHZlcnkgYmFkXG4gICAgICBpZiAobWFya3R5cGUgPT09IFRFWFQpIHJldHVybiBCQUQ7XG4gICAgICBpZiAobWFya3R5cGUgPT09ICdsaW5lJykgcmV0dXJuIEJBRDtcbiAgICAgIHJldHVybiBNLnNpemU7XG4gICAgY2FzZSBDT0xPUjogcmV0dXJuIE0uY29sb3I7XG4gICAgY2FzZSBURVhUOiByZXR1cm4gTS50ZXh0O1xuICB9XG4gIHJldHVybiBCQUQ7XG59O1xuXG5yYW5rRW5jb2RpbmdzLm1lYXN1cmVTY29yZS5jb25zdHMgPSBNO1xuXG5cbnJhbmtFbmNvZGluZ3Muc2NvcmUgPSB7XG4gIGRpbWVuc2lvbjogcmFua0VuY29kaW5ncy5kaW1lbnNpb25TY29yZSxcbiAgbWVhc3VyZTogcmFua0VuY29kaW5ncy5tZWFzdXJlU2NvcmUsXG59O1xuIiwiXCJ1c2Ugc3RyaWN0XCI7XG5cbnZhciBjb25zdHMgPSByZXF1aXJlKCcuL2NvbnN0cycpO1xuXG52YXIgdXRpbCA9IG1vZHVsZS5leHBvcnRzID0ge1xuICBnZW46IHt9XG59O1xuXG51dGlsLmlzQXJyYXkgPSBBcnJheS5pc0FycmF5IHx8IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIHt9LnRvU3RyaW5nLmNhbGwob2JqKSA9PSAnW29iamVjdCBBcnJheV0nO1xufTtcblxudXRpbC5qc29uID0gZnVuY3Rpb24ocywgc3ApIHtcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHMsIG51bGwsIHNwKTtcbn07XG5cbnV0aWwua2V5cyA9IGZ1bmN0aW9uKG9iaikge1xuICB2YXIgayA9IFtdLCB4O1xuICBmb3IgKHggaW4gb2JqKSBrLnB1c2goeCk7XG4gIHJldHVybiBrO1xufTtcblxudXRpbC5uZXN0ZWRNYXAgPSBmdW5jdGlvbiAoY29sLCBmLCBsZXZlbCwgZmlsdGVyKSB7XG4gIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgY29sLm1hcChmKSA6XG4gICAgY29sLm1hcChmdW5jdGlvbih2KSB7XG4gICAgICB2YXIgciA9IHV0aWwubmVzdGVkTWFwKHYsIGYsIGxldmVsIC0gMSk7XG4gICAgICByZXR1cm4gZmlsdGVyID8gci5maWx0ZXIodXRpbC5ub25FbXB0eSkgOiByO1xuICAgIH0pO1xufTtcblxudXRpbC5uZXN0ZWRSZWR1Y2UgPSBmdW5jdGlvbiAoY29sLCBmLCBsZXZlbCwgZmlsdGVyKSB7XG4gIHJldHVybiBsZXZlbCA9PT0gMCA/XG4gICAgY29sLnJlZHVjZShmLCBbXSkgOlxuICAgIGNvbC5tYXAoZnVuY3Rpb24odikge1xuICAgICAgdmFyIHIgPSB1dGlsLm5lc3RlZFJlZHVjZSh2LCBmLCBsZXZlbCAtIDEpO1xuICAgICAgcmV0dXJuIGZpbHRlciA/IHIuZmlsdGVyKHV0aWwubm9uRW1wdHkpIDogcjtcbiAgICB9KTtcbn07XG5cbnV0aWwubm9uRW1wdHkgPSBmdW5jdGlvbihncnApIHtcbiAgcmV0dXJuICF1dGlsLmlzQXJyYXkoZ3JwKSB8fCBncnAubGVuZ3RoID4gMDtcbn07XG5cblxudXRpbC50cmF2ZXJzZSA9IGZ1bmN0aW9uIChub2RlLCBhcnIpIHtcbiAgaWYgKG5vZGUudmFsdWUgIT09IHVuZGVmaW5lZCkge1xuICAgIGFyci5wdXNoKG5vZGUudmFsdWUpO1xuICB9IGVsc2Uge1xuICAgIGlmIChub2RlLmxlZnQpIHV0aWwudHJhdmVyc2Uobm9kZS5sZWZ0LCBhcnIpO1xuICAgIGlmIChub2RlLnJpZ2h0KSB1dGlsLnRyYXZlcnNlKG5vZGUucmlnaHQsIGFycik7XG4gIH1cbiAgcmV0dXJuIGFycjtcbn07XG5cbnV0aWwudW5pb24gPSBmdW5jdGlvbiAoYSwgYikge1xuICB2YXIgbyA9IHt9O1xuICBhLmZvckVhY2goZnVuY3Rpb24oeCkgeyBvW3hdID0gdHJ1ZTt9KTtcbiAgYi5mb3JFYWNoKGZ1bmN0aW9uKHgpIHsgb1t4XSA9IHRydWU7fSk7XG4gIHJldHVybiB1dGlsLmtleXMobyk7XG59O1xuXG5cbnV0aWwuZ2VuLmdldE9wdCA9IGZ1bmN0aW9uIChvcHQpIHtcbiAgLy9tZXJnZSB3aXRoIGRlZmF1bHRcbiAgcmV0dXJuIChvcHQgPyB1dGlsLmtleXMob3B0KSA6IFtdKS5yZWR1Y2UoZnVuY3Rpb24oYywgaykge1xuICAgIGNba10gPSBvcHRba107XG4gICAgcmV0dXJuIGM7XG4gIH0sIE9iamVjdC5jcmVhdGUoY29uc3RzLmdlbi5ERUZBVUxUX09QVCkpO1xufTtcblxuLyoqXG4gKiBwb3dlcnNldCBjb2RlIGZyb20gaHR0cDovL3Jvc2V0dGFjb2RlLm9yZy93aWtpL1Bvd2VyX1NldCNKYXZhU2NyaXB0XG4gKlxuICogICB2YXIgcmVzID0gcG93ZXJzZXQoWzEsMiwzLDRdKTtcbiAqXG4gKiByZXR1cm5zXG4gKlxuICogW1tdLFsxXSxbMl0sWzEsMl0sWzNdLFsxLDNdLFsyLDNdLFsxLDIsM10sWzRdLFsxLDRdLFxuICogWzIsNF0sWzEsMiw0XSxbMyw0XSxbMSwzLDRdLFsyLDMsNF0sWzEsMiwzLDRdXVxuW2VkaXRdXG4qL1xuXG51dGlsLnBvd2Vyc2V0ID0gZnVuY3Rpb24obGlzdCkge1xuICB2YXIgcHMgPSBbXG4gICAgW11cbiAgXTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgZm9yICh2YXIgaiA9IDAsIGxlbiA9IHBzLmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICBwcy5wdXNoKHBzW2pdLmNvbmNhdChsaXN0W2ldKSk7XG4gICAgfVxuICB9XG4gIHJldHVybiBwcztcbn07XG5cbnV0aWwuY2hvb3NlS29yTGVzcyA9IGZ1bmN0aW9uKGxpc3QsIGspIHtcbiAgdmFyIHN1YnNldCA9IFtbXV07XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIGZvciAodmFyIGogPSAwLCBsZW4gPSBzdWJzZXQubGVuZ3RoOyBqIDwgbGVuOyBqKyspIHtcbiAgICAgIHZhciBzdWIgPSBzdWJzZXRbal0uY29uY2F0KGxpc3RbaV0pO1xuICAgICAgaWYoc3ViLmxlbmd0aCA8PSBrKXtcbiAgICAgICAgc3Vic2V0LnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIHN1YnNldDtcbn07XG5cbnV0aWwuY2hvb3NlSyA9IGZ1bmN0aW9uKGxpc3QsIGspIHtcbiAgdmFyIHN1YnNldCA9IFtbXV07XG4gIHZhciBrQXJyYXkgPVtdO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspIHtcbiAgICBmb3IgKHZhciBqID0gMCwgbGVuID0gc3Vic2V0Lmxlbmd0aDsgaiA8IGxlbjsgaisrKSB7XG4gICAgICB2YXIgc3ViID0gc3Vic2V0W2pdLmNvbmNhdChsaXN0W2ldKTtcbiAgICAgIGlmKHN1Yi5sZW5ndGggPCBrKXtcbiAgICAgICAgc3Vic2V0LnB1c2goc3ViKTtcbiAgICAgIH1lbHNlIGlmIChzdWIubGVuZ3RoID09PSBrKXtcbiAgICAgICAga0FycmF5LnB1c2goc3ViKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIGtBcnJheTtcbn07XG5cbnV0aWwuY3Jvc3MgPSBmdW5jdGlvbihhLGIpe1xuICB2YXIgeCA9IFtdO1xuICBmb3IodmFyIGk9MDsgaTwgYS5sZW5ndGg7IGkrKyl7XG4gICAgZm9yKHZhciBqPTA7ajwgYi5sZW5ndGg7IGorKyl7XG4gICAgICB4LnB1c2goYVtpXS5jb25jYXQoYltqXSkpO1xuICAgIH1cbiAgfVxuICByZXR1cm4geDtcbn07XG5cbiIsIid1c2Ugc3RyaWN0JztcblxuLy8gZGVjbGFyZSBnbG9iYWwgY29uc3RhbnRcbnZhciBnID0gZ2xvYmFsIHx8IHdpbmRvdztcblxuZy5BR0dSRUdBVEUgPSAnYWdncmVnYXRlJztcbmcuUkFXID0gJ3Jhdyc7XG5nLlNUQUNLRUQgPSAnc3RhY2tlZCc7XG5nLklOREVYID0gJ2luZGV4JztcblxuZy5YID0gJ3gnO1xuZy5ZID0gJ3knO1xuZy5ST1cgPSAncm93JztcbmcuQ09MID0gJ2NvbCc7XG5nLlNJWkUgPSAnc2l6ZSc7XG5nLlNIQVBFID0gJ3NoYXBlJztcbmcuQ09MT1IgPSAnY29sb3InO1xuZy5URVhUID0gJ3RleHQnO1xuZy5ERVRBSUwgPSAnZGV0YWlsJztcblxuZy5OID0gJ04nO1xuZy5PID0gJ08nO1xuZy5RID0gJ1EnO1xuZy5UID0gJ1QnO1xuIl19\n","module.exports = {\n  euclidean: function(v1, v2) {\n      var total = 0;\n      for (var i = 0; i < v1.length; i++) {\n         total += Math.pow(v2[i] - v1[i], 2);      \n      }\n      return Math.sqrt(total);\n   },\n   manhattan: function(v1, v2) {\n     var total = 0;\n     for (var i = 0; i < v1.length ; i++) {\n        total += Math.abs(v2[i] - v1[i]);      \n     }\n     return total;\n   },\n   max: function(v1, v2) {\n     var max = 0;\n     for (var i = 0; i < v1.length; i++) {\n        max = Math.max(max , Math.abs(v2[i] - v1[i]));      \n     }\n     return max;\n   }\n};","var distances = require(\"./distance\");\n\nvar HierarchicalClustering = function(distance, linkage, threshold) {\n   this.distance = distance;\n   this.linkage = linkage;\n   this.threshold = threshold == undefined ? Infinity : threshold;\n}\n\nHierarchicalClustering.prototype = {\n   cluster : function(items, snapshotPeriod, snapshotCb) {\n      this.clusters = [];\n      this.dists = [];  // distances between each pair of clusters\n      this.mins = []; // closest cluster for each cluster\n      this.index = []; // keep a hash of all clusters by key\n      \n      for (var i = 0; i < items.length; i++) {\n         var cluster = {\n            value: items[i],\n            key: i,\n            index: i,\n            size: 1\n         };\n         this.clusters[i] = cluster;\n         this.index[i] = cluster;\n         this.dists[i] = [];\n         this.mins[i] = 0;\n      }\n\n      for (var i = 0; i < this.clusters.length; i++) {\n         for (var j = 0; j <= i; j++) {\n            var dist = (i == j) ? Infinity : \n               this.distance(this.clusters[i].value, this.clusters[j].value);\n            this.dists[i][j] = dist;\n            this.dists[j][i] = dist;\n\n            if (dist < this.dists[i][this.mins[i]]) {\n               this.mins[i] = j;               \n            }\n         }\n      }\n\n      var merged = this.mergeClosest();\n      var i = 0;\n      while (merged) {\n        if (snapshotCb && (i++ % snapshotPeriod) == 0) {\n           snapshotCb(this.clusters);           \n        }\n        merged = this.mergeClosest();\n      }\n    \n      this.clusters.forEach(function(cluster) {\n        // clean up metadata used for clustering\n        delete cluster.key;\n        delete cluster.index;\n      });\n\n      return this.clusters;\n   },\n  \n   mergeClosest: function() {\n      // find two closest clusters from cached mins\n      var minKey = 0, min = Infinity;\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key = this.clusters[i].key,\n             dist = this.dists[key][this.mins[key]];\n         if (dist < min) {\n            minKey = key;\n            min = dist;\n         }\n      }\n      if (min >= this.threshold) {\n         return false;         \n      }\n\n      var c1 = this.index[minKey],\n          c2 = this.index[this.mins[minKey]];\n\n      // merge two closest clusters\n      var merged = {\n         left: c1,\n         right: c2,\n         key: c1.key,\n         size: c1.size + c2.size\n      };\n\n      this.clusters[c1.index] = merged;\n      this.clusters.splice(c2.index, 1);\n      this.index[c1.key] = merged;\n\n      // update distances with new merged cluster\n      for (var i = 0; i < this.clusters.length; i++) {\n         var ci = this.clusters[i];\n         var dist;\n         if (c1.key == ci.key) {\n            dist = Infinity;            \n         }\n         else if (this.linkage == \"single\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] > this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];\n            }\n         }\n         else if (this.linkage == \"complete\") {\n            dist = this.dists[c1.key][ci.key];\n            if (this.dists[c1.key][ci.key] < this.dists[c2.key][ci.key]) {\n               dist = this.dists[c2.key][ci.key];              \n            }\n         }\n         else if (this.linkage == \"average\") {\n            dist = (this.dists[c1.key][ci.key] * c1.size\n                   + this.dists[c2.key][ci.key] * c2.size) / (c1.size + c2.size);\n         }\n         else {\n            dist = this.distance(ci.value, c1.value);            \n         }\n\n         this.dists[c1.key][ci.key] = this.dists[ci.key][c1.key] = dist;\n      }\n\n    \n      // update cached mins\n      for (var i = 0; i < this.clusters.length; i++) {\n         var key1 = this.clusters[i].key;        \n         if (this.mins[key1] == c1.key || this.mins[key1] == c2.key) {\n            var min = key1;\n            for (var j = 0; j < this.clusters.length; j++) {\n               var key2 = this.clusters[j].key;\n               if (this.dists[key1][key2] < this.dists[key1][min]) {\n                  min = key2;                  \n               }\n            }\n            this.mins[key1] = min;\n         }\n         this.clusters[i].index = i;\n      }\n    \n      // clean up metadata used for clustering\n      delete c1.key; delete c2.key;\n      delete c1.index; delete c2.index;\n\n      return true;\n   }\n}\n\nvar hcluster = function(items, distance, linkage, threshold, snapshot, snapshotCallback) {\n   distance = distance || \"euclidean\";\n   linkage = linkage || \"average\";\n\n   if (typeof distance == \"string\") {\n     distance = distances[distance];\n   }\n   var clusters = (new HierarchicalClustering(distance, linkage, threshold))\n                  .cluster(items, snapshot, snapshotCallback);\n      \n   if (threshold === undefined) {\n      return clusters[0]; // all clustered into one\n   }\n   return clusters;\n}\n\nmodule.exports = hcluster;\n","var distances = require(\"./distance\");\n\nfunction KMeans(centroids) {\n   this.centroids = centroids || [];\n}\n\nKMeans.prototype.randomCentroids = function(points, k) {\n   var centroids = points.slice(0); // copy\n   centroids.sort(function() {\n      return (Math.round(Math.random()) - 0.5);\n   });\n   return centroids.slice(0, k);\n}\n\nKMeans.prototype.classify = function(point, distance) {\n   var min = Infinity,\n       index = 0;\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   for (var i = 0; i < this.centroids.length; i++) {\n      var dist = distance(point, this.centroids[i]);\n      if (dist < min) {\n         min = dist;\n         index = i;\n      }\n   }\n\n   return index;\n}\n\nKMeans.prototype.cluster = function(points, k, distance, snapshotPeriod, snapshotCb) {\n   k = k || Math.max(2, Math.ceil(Math.sqrt(points.length / 2)));\n\n   distance = distance || \"euclidean\";\n   if (typeof distance == \"string\") {\n      distance = distances[distance];\n   }\n\n   this.centroids = this.randomCentroids(points, k);\n\n   var assignment = new Array(points.length);\n   var clusters = new Array(k);\n\n   var iterations = 0;\n   var movement = true;\n   while (movement) {\n      // update point-to-centroid assignments\n      for (var i = 0; i < points.length; i++) {\n         assignment[i] = this.classify(points[i], distance);\n      }\n\n      // update location of each centroid\n      movement = false;\n      for (var j = 0; j < k; j++) {\n         var assigned = [];\n         for (var i = 0; i < assignment.length; i++) {\n            if (assignment[i] == j) {\n               assigned.push(points[i]);\n            }\n         }\n\n         if (!assigned.length) {\n            continue;\n         }\n\n         var centroid = this.centroids[j];\n         var newCentroid = new Array(centroid.length);\n\n         for (var g = 0; g < centroid.length; g++) {\n            var sum = 0;\n            for (var i = 0; i < assigned.length; i++) {\n               sum += assigned[i][g];\n            }\n            newCentroid[g] = sum / assigned.length;\n\n            if (newCentroid[g] != centroid[g]) {\n               movement = true;\n            }\n         }\n\n         this.centroids[j] = newCentroid;\n         clusters[j] = assigned;\n      }\n\n      if (snapshotCb && (iterations++ % snapshotPeriod == 0)) {\n         snapshotCb(clusters);\n      }\n   }\n\n   return clusters;\n}\n\nKMeans.prototype.toJSON = function() {\n   return JSON.stringify(this.centroids);\n}\n\nKMeans.prototype.fromJSON = function(json) {\n   this.centroids = JSON.parse(json);\n   return this;\n}\n\nmodule.exports = KMeans;\n\nmodule.exports.kmeans = function(vectors, k) {\n   return (new KMeans()).cluster(vectors, k);\n}","\"use strict\";\n\nmodule.exports = cluster;\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  clusterfck = require('clusterfck'),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\ncluster.distance = require('./distance');\n\nfunction cluster(encodings, opt) {\n  // jshint unused:false\n  var dist = cluster.distance.table(encodings);\n\n  var clusterTrees = clusterfck.hcluster(encodings, function(e1, e2) {\n    var s1 = vl.Encoding.shorthand(e1),\n      s2 = vl.Encoding.shorthand(e2);\n    return dist[s1][s2];\n  }, 'average', consts.CLUSTER_THRESHOLD);\n\n  var clusters = clusterTrees.map(function(tree) {\n      return util.traverse(tree, []);\n    })\n   .map(function(cluster) {\n    return cluster.sort(function(encoding1, encoding2) {\n      // sort each cluster -- have the highest score as 1st item\n      return encoding2._info.score - encoding1._info.score;\n    });\n  }).filter(function(cluster) {  // filter empty cluster\n    return cluster.length >0;\n  }).sort(function(cluster1, cluster2) {\n    //sort by highest scoring item in each cluster\n    return cluster2[0]._info.score - cluster1[0]._info.score;\n  });\n\n  clusters.dist = dist; //append dist in the array for debugging\n\n  return clusters;\n}","'use strict';\n\nvar c = module.exports = {};\n\nc.SWAPPABLE = 0.05;\nc.DIST_MISSING = 1;\nc.CLUSTER_THRESHOLD = 1;\n\nfunction reduceTupleToTable(r, x) {\n  var a = x[0], b = x[1], d = x[2];\n  r[a] = r[a] || {};\n  r[b] = r[b] || {};\n  r[a][b] = r[b][a] = d;\n  return r;\n}\n\nc.DIST_BY_ENCTYPE = [\n  // positional\n  ['x', 'y', c.SWAPPABLE],\n  ['row', 'col', c.SWAPPABLE],\n\n  // ordinal mark properties\n  ['color', 'shape', c.SWAPPABLE],\n  ['color', 'detail', c.SWAPPABLE],\n  ['detail', 'shape', c.SWAPPABLE],\n\n  // quantitative mark properties\n  ['size', 'color', c.SWAPPABLE]\n].reduce(reduceTupleToTable, {});\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  consts = require('./clusterconsts'),\n  util = require('../util');\n\nvar distance = {};\nmodule.exports = distance;\n\ndistance.table = function (encodings) {\n  var len = encodings.length,\n    colencs = encodings.map(function(e) { return distance.getEncTypeByColumnName(e); }),\n    shorthands = encodings.map(vl.Encoding.shorthand),\n    diff = {}, i, j;\n\n  for (i = 0; i < len; i++) diff[shorthands[i]] = {};\n\n  for (i = 0; i < len; i++) {\n    for (j = i + 1; j < len; j++) {\n      var sj = shorthands[j], si = shorthands[i];\n\n      diff[sj][si] = diff[si][sj] = distance.get(colencs[i], colencs[j]);\n    }\n  }\n  return diff;\n};\n\ndistance.get = function (colenc1, colenc2) {\n  var cols = util.union(vl.keys(colenc1.col), vl.keys(colenc2.col)),\n    dist = 0;\n\n  cols.forEach(function(col) {\n    var e1 = colenc1.col[col], e2 = colenc2.col[col];\n\n    if (e1 && e2) {\n      if (e1.encType != e2.encType) {\n        dist += (consts.DIST_BY_ENCTYPE[e1.encType] || {})[e2.encType] || 1;\n      }\n    } else {\n      dist += consts.DIST_MISSING;\n    }\n  });\n\n  // do not group stacked chart with similar non-stacked chart!\n  var isStack1 = vl.Encoding.isStack(colenc1),\n    isStack2 = vl.Encoding.isStack(colenc2);\n\n  if(isStack1 || isStack2) {\n    if(isStack1 && isStack2) {\n      if(colenc1.encoding.color.name !== colenc2.encoding.color.name) {\n        dist+=1;\n      }\n    } else {\n      dist+=1; // surely different\n    }\n  }\n  return dist;\n};\n\n// get encoding type by fieldname\ndistance.getEncTypeByColumnName = function(encoding) {\n  var _colenc = {},\n    enc = encoding.encoding;\n\n  vl.keys(enc).forEach(function(encType) {\n    var e = vl.duplicate(enc[encType]);\n    e.encType = encType;\n    _colenc[e.name || ''] = e;\n    delete e.name;\n  });\n\n  return {\n    marktype: encoding.marktype,\n    col: _colenc,\n    encoding: encoding.encoding\n  };\n};","'use strict';\n\nvar consts = module.exports = {\n  gen: {},\n  cluster: {},\n  rank: {}\n};\n\nconsts.gen.projections = {\n  type: 'object',\n  properties: {\n    omitDotPlot: { //FIXME remove this!\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    maxCardinalityForAutoAddOrdinal: {\n      type: 'integer',\n      default: 50,\n      description: 'max cardinality for ordinal field to be considered for auto adding'\n    },\n    alwaysAddHistogram: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\nconsts.gen.aggregates = {\n  type: 'object',\n  properties: {\n    config: {\n      type: 'object'\n    },\n    data: {\n      type: 'object'\n    },\n    tableTypes: {\n      type: 'boolean',\n      default: 'both',\n      enum: ['both', 'aggregated', 'disaggregated']\n    },\n    genDimQ: {\n      type: 'string',\n      default: 'auto',\n      enum: ['auto', 'bin', 'cast', 'none'],\n      description: 'Use Q as Dimension either by binning or casting'\n    },\n    minCardinalityForBin: {\n      type: 'integer',\n      default: 20,\n      description: 'minimum cardinality of a field if we were to bin'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitMeasureOnly: {\n      type: 'boolean',\n      default: false,\n      description: 'Omit aggregation with measure(s) only'\n    },\n    omitDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Omit aggregation with dimension(s) only'\n    },\n    addCountForDimensionOnly: {\n      type: 'boolean',\n      default: true,\n      description: 'Add count when there are dimension(s) only'\n    },\n    aggrList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: [undefined, 'mean']\n    },\n    timeUnitList: {\n      type: 'array',\n      items: {\n        type: ['string']\n      },\n      default: ['year']\n    },\n    consistentAutoQ: {\n      type: 'boolean',\n      default: true,\n      description: \"generate similar auto transform for quant\"\n    }\n  }\n};\n\nconsts.gen.encodings = {\n  type: 'object',\n  properties: {\n    marktypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['point', 'bar', 'line', 'area', 'text', 'tick'], //filled_map\n      description: 'allowed marktypes'\n    },\n    encodingTypeList: {\n      type: 'array',\n      items: {type: 'string'},\n      default: ['x', 'y', 'row', 'col', 'size', 'color', 'text', 'detail'],\n      description: 'allowed encoding types'\n    },\n    maxGoodCardinalityForFacets: {\n      type: 'integer',\n      default: 5,\n      description: 'maximum cardinality of a field to be put on facet (row/col) effectively'\n    },\n    maxCardinalityForFacets: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of a field to be put on facet (row/col)'\n    },\n    maxGoodCardinalityForColor: {\n      type: 'integer',\n      default: 7,\n      description: 'maximum cardinality of an ordinal field to be put on color effectively'\n    },\n    maxCardinalityForColor: {\n      type: 'integer',\n      default: 20,\n      description: 'maximum cardinality of an ordinal field to be put on color'\n    },\n    maxCardinalityForShape: {\n      type: 'integer',\n      default: 6,\n      description: 'maximum cardinality of an ordinal field to be put on shape'\n    },\n    omitTranpose:  {\n      type: 'boolean',\n      default: true,\n      description: 'Eliminate all transpose by (1) keeping horizontal dot plot only (2) for OxQ charts, always put O on Y (3) show only one DxD, MxM (currently sorted by name)'\n    },\n    omitDotPlot: {\n      type: 'boolean',\n      default: false,\n      description: 'remove all dot plots'\n    },\n    omitDotPlotWithExtraEncoding: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all dot plots with >1 encoding'\n    },\n    omitMultipleRetinalEncodings: {\n      type: 'boolean',\n      default: true,\n      description: 'omit using multiple retinal variables (size, color, shape)'\n    },\n    omitNonTextAggrWithAllDimsOnFacets: {\n      type: 'boolean',\n      default: true,\n      description: 'remove all aggregated charts (except text tables) with all dims on facets (row, col)'\n    },\n    omitOneDimensionCount: {\n      type: 'boolean',\n      default: false,\n      description: 'omit one dimension count'\n    },\n    omitSizeOnBar: {\n      type: 'boolean',\n      default: false,\n      description: 'do not use bar\\'s size'\n    },\n    omitStackedAverage: {\n      type: 'boolean',\n      default: true,\n      description: 'do not stack bar chart with average'\n    },\n    alwaysGenerateTableAsHeatmap: {\n      type: 'boolean',\n      default: true\n    }\n  }\n};\n\n\n\n","module.exports = {\n  consts: require('./consts'),\n  cluster: require('./cluster/cluster'),\n  gen: require('./gen/gen'),\n  rank: require('./rank/rank'),\n  util: require('./util'),\n  auto: \"-, sum\"\n};\n\n\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null);\n\nvar consts = require('../consts');\n\nvar AUTO='*';\n\nmodule.exports = genAggregates;\n\nfunction genAggregates(output, fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.aggregates);\n  var tf = new Array(fields.length);\n  var hasNorO = vl.any(fields, function(f) {\n    return vl.encDef.isTypes(f, [N, O]);\n  });\n\n  function emit(fieldSet) {\n    fieldSet = vl.duplicate(fieldSet);\n    fieldSet.key = vl.encDef.shorthands(fieldSet);\n    output.push(fieldSet);\n  }\n\n  function checkAndPush() {\n    if (opt.omitMeasureOnly || opt.omitDimensionOnly) {\n      var hasMeasure = false, hasDimension = false, hasRaw = false;\n      tf.forEach(function(f) {\n        if (vl.encDef.isDimension(f)) {\n          hasDimension = true;\n        } else {\n          hasMeasure = true;\n          if (!f.aggregate) hasRaw = true;\n        }\n      });\n      if (!hasDimension && !hasRaw && opt.omitMeasureOnly) return;\n      if (!hasMeasure) {\n        if (opt.addCountForDimensionOnly) {\n          tf.push(vl.encDef.count());\n          emit(tf);\n          tf.pop();\n        }\n        if (opt.omitDimensionOnly) return;\n      }\n    }\n    if (opt.omitDotPlot && tf.length === 1) return;\n    emit(tf);\n  }\n\n  function assignAggrQ(i, hasAggr, autoMode, a) {\n    var canHaveAggr = hasAggr === true || hasAggr === null,\n      cantHaveAggr = hasAggr === false || hasAggr === null;\n    if (a) {\n      if (canHaveAggr) {\n        tf[i].aggregate = a;\n        assignField(i + 1, true, autoMode);\n        delete tf[i].aggregate;\n      }\n    } else { // if(a === undefined)\n      if (cantHaveAggr) {\n        assignField(i + 1, false, autoMode);\n      }\n    }\n  }\n\n  function assignBinQ(i, hasAggr, autoMode) {\n    tf[i].bin = true;\n    assignField(i + 1, hasAggr, autoMode);\n    delete tf[i].bin;\n  }\n\n  function assignQ(i, hasAggr, autoMode) {\n    var f = fields[i],\n      canHaveAggr = hasAggr === true || hasAggr === null;\n\n    tf[i] = {name: f.name, type: f.type};\n\n    if (f.aggregate === 'count') { // if count is included in the selected fields\n      if (canHaveAggr) {\n        tf[i].aggregate = f.aggregate;\n        assignField(i + 1, true, autoMode);\n      }\n    } else if (f._aggregate) {\n      // TODO support array of f._aggrs too\n      assignAggrQ(i, hasAggr, autoMode, f._aggregate);\n    } else if (f._raw) {\n      assignAggrQ(i, hasAggr, autoMode, undefined);\n    } else if (f._bin) {\n      assignBinQ(i, hasAggr, autoMode);\n    } else {\n      opt.aggrList.forEach(function(a) {\n        if (!opt.consistentAutoQ || autoMode === AUTO || autoMode === a) {\n          assignAggrQ(i, hasAggr, a /*assign autoMode*/, a);\n        }\n      });\n\n      if ((!opt.consistentAutoQ || vl.isin(autoMode, [AUTO, 'bin', 'cast', 'autocast'])) && !hasNorO) {\n        var highCardinality = vl.encDef.cardinality(f, stats) > opt.minCardinalityForBin;\n\n        var isAuto = opt.genDimQ === 'auto',\n          genBin = opt.genDimQ  === 'bin' || (isAuto && highCardinality),\n          genCast = opt.genDimQ === 'cast' || (isAuto && !highCardinality);\n\n        if (genBin && vl.isin(autoMode, [AUTO, 'bin', 'autocast'])) {\n          assignBinQ(i, hasAggr, isAuto ? 'autocast' : 'bin');\n        }\n        if (genCast && vl.isin(autoMode, [AUTO, 'cast', 'autocast'])) {\n          tf[i].type = 'O';\n          assignField(i + 1, hasAggr, isAuto ? 'autocast' : 'cast');\n          tf[i].type = 'Q';\n        }\n      }\n    }\n  }\n\n  function assignTimeUnitT(i, hasAggr, autoMode, timeUnit) {\n    tf[i].timeUnit = timeUnit;\n    assignField(i+1, hasAggr, autoMode);\n    delete tf[i].timeUnit;\n  }\n\n  function assignT(i, hasAggr, autoMode) {\n    var f = fields[i];\n    tf[i] = {name: f.name, type: f.type};\n\n    // TODO support array of f._timeUnits\n    if (f._timeUnit) {\n      assignTimeUnitT(i, hasAggr, autoMode, f._timeUnit);\n    } else {\n      opt.timeUnitList.forEach(function(timeUnit) {\n        if (timeUnit === undefined) {\n          if (!hasAggr) { // can't aggregate over raw time\n            assignField(i+1, false, autoMode);\n          }\n        } else {\n          assignTimeUnitT(i, hasAggr, autoMode, timeUnit);\n        }\n      });\n    }\n\n    // FIXME what if you aggregate time?\n  }\n\n  function assignField(i, hasAggr, autoMode) {\n    if (i === fields.length) { // If all fields are assigned\n      checkAndPush();\n      return;\n    }\n\n    var f = fields[i];\n    // Otherwise, assign i-th field\n    switch (f.type) {\n      //TODO \"D\", \"G\"\n      case Q:\n        assignQ(i, hasAggr, autoMode);\n        break;\n\n      case T:\n        assignT(i, hasAggr, autoMode);\n        break;\n      case O:\n        /* falls through */\n      case N:\n        /* falls through */\n      default:\n        tf[i] = f;\n        assignField(i + 1, hasAggr, autoMode);\n        break;\n    }\n  }\n\n  var hasAggr = opt.tableTypes === 'aggregated' ? true : opt.tableTypes === 'disaggregated' ? false : null;\n  assignField(0, hasAggr, AUTO);\n\n  return output;\n}\n","'use strict';\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genEncs = require('./encs'),\n  getMarktypes = require('./marktypes'),\n  rank = require('../rank/rank'),\n  consts = require('../consts');\n\nmodule.exports = genEncodingsFromFields;\n\nfunction genEncodingsFromFields(output, fields, stats, opt, nested) {\n  // opt must be augmented before being passed to genEncs or getMarktypes\n  opt = vl.schema.util.extend(opt||{}, consts.gen.encodings);\n  var encs = genEncs([], fields, stats, opt);\n\n  if (nested) {\n    return encs.reduce(function(dict, enc) {\n      dict[enc] = genEncodingsFromEncs([], enc, stats, opt);\n      return dict;\n    }, {});\n  } else {\n    return encs.reduce(function(list, enc) {\n      return genEncodingsFromEncs(list, enc, stats, opt);\n    }, []);\n  }\n}\n\nfunction genEncodingsFromEncs(output, enc, stats, opt) {\n  getMarktypes(enc, stats, opt)\n    .forEach(function(markType) {\n      var e = vl.duplicate({\n          // Clone config & encoding to unique objects\n          encoding: enc,\n          config: opt.config\n        });\n\n      e.marktype = markType;\n      // Data object is the same across charts: pass by reference\n      e.data = opt.data;\n\n      var encoding = finalTouch(e, stats, opt);\n      var score = rank.encoding(encoding, stats, opt);\n\n      encoding._info = score;\n      output.push(encoding);\n    });\n  return output;\n}\n\n//FIXME this should be refactors\nfunction finalTouch(encoding, stats, opt) {\n  if (encoding.marktype === 'text' && opt.alwaysGenerateTableAsHeatmap) {\n    encoding.encoding.color = encoding.encoding.text;\n  }\n\n  // don't include zero if stdev/mean < 0.01\n  // https://github.com/uwdata/visrec/issues/69\n  var enc = encoding.encoding;\n  ['x', 'y'].forEach(function(et) {\n    var field = enc[et];\n    if (field && vl.encDef.isMeasure(field) && !vl.encDef.isCount(field)) {\n      var stat = stats[field.name];\n      if (stat && stat.stdev / stat.mean < 0.01) {\n        field.scale = {zero: false};\n      }\n    }\n  });\n  return encoding;\n}\n","\"use strict\";\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  genMarkTypes = require('./marktypes'),\n  isDimension = vl.encDef.isDimension,\n  isMeasure = vl.encDef.isMeasure;\n\nmodule.exports = genEncs;\n\n// FIXME remove dimension, measure and use information in vega-lite instead!\nvar rules = {\n  x: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  y: {\n    dimension: true,\n    measure: true,\n    multiple: true //FIXME should allow multiple only for Q, T\n  },\n  row: {\n    dimension: true,\n    multiple: true\n  },\n  col: {\n    dimension: true,\n    multiple: true\n  },\n  shape: {\n    dimension: true,\n    rules: shapeRules\n  },\n  size: {\n    measure: true,\n    rules: retinalEncRules\n  },\n  color: {\n    dimension: true,\n    measure: true,\n    rules: colorRules\n  },\n  text: {\n    measure: true\n  },\n  detail: {\n    dimension: true\n  }\n  //geo: {\n  //  geo: true\n  //},\n  //arc: { // pie\n  //\n  //}\n};\n\nfunction retinalEncRules(enc, field, stats, opt) {\n  if (opt.omitMultipleRetinalEncodings) {\n    if (enc.color || enc.size || enc.shape) return false;\n  }\n  return true;\n}\n\nfunction colorRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  return vl.encDef.isMeasure(field) ||\n    vl.encDef.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction shapeRules(enc, field, stats, opt) {\n  if(!retinalEncRules(enc, field, stats, opt)) return false;\n\n  if (field.bin && field.type === Q) return false;\n  if (field.timeUnit && field.type === T) return false;\n  return vl.encDef.cardinality(field, stats) <= opt.maxCardinalityForColor;\n}\n\nfunction dimMeaTransposeRule(enc) {\n  // create horizontal histogram for ordinal\n  if (vl.encDef.isTypes(enc.y, [N, O]) && isMeasure(enc.x)) return true;\n\n  // vertical histogram for Q and T\n  if (isMeasure(enc.y) && (!vl.encDef.isTypes(enc.x, [N, O]) && isDimension(enc.x))) return true;\n\n  return false;\n}\n\nfunction generalRules(enc, stats, opt) {\n  // enc.text is only used for TEXT TABLE\n  if (enc.text) {\n    return genMarkTypes.satisfyRules(enc, TEXT, stats, opt);\n  }\n\n  // CARTESIAN PLOT OR MAP\n  if (enc.x || enc.y || enc.geo || enc.arc) {\n\n    if (enc.row || enc.col) { //have facet(s)\n\n      // don't use facets before filling up x,y\n      if (!enc.x || !enc.y) return false;\n\n      if (opt.omitNonTextAggrWithAllDimsOnFacets) {\n        // remove all aggregated charts with all dims on facets (row, col)\n        if (genEncs.isAggrWithAllDimOnFacets(enc)) return false;\n      }\n    }\n\n    if (enc.x && enc.y) {\n      var isDimX = !!isDimension(enc.x),\n        isDimY = !!isDimension(enc.y);\n\n      if (isDimX && isDimY && !vl.enc.isAggregate(enc)) {\n        // FIXME actually check if there would be occlusion #90\n        return false;\n      }\n\n      if (opt.omitTranpose) {\n        if (isDimX ^ isDimY) { // dim x mea\n          if (!dimMeaTransposeRule(enc)) return false;\n        } else if (enc.y.type===T || enc.x.type === T) {\n          if (enc.y.type===T && enc.x.type !== T) return false;\n        } else { // show only one OxO, QxQ\n          if (enc.x.name > enc.y.name) return false;\n        }\n      }\n      return true;\n    }\n\n    // DOT PLOTS\n    // // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    if (opt.omitOneDimensionCount) {\n      // one dimension \"count\"\n    if (enc.x && enc.x.aggregate == 'count' && !enc.y) return false;\n    if (enc.y && enc.y.aggregate == 'count' && !enc.x) return false;\n    }\n\n    return true;\n  }\n  return false;\n}\n\ngenEncs.isAggrWithAllDimOnFacets = function (enc) {\n  var hasAggr = false, hasOtherO = false;\n  for (var encType in enc) {\n    var field = enc[encType];\n    if (field.aggregate) {\n      hasAggr = true;\n    }\n    if (vl.encDef.isDimension(field) && (encType !== ROW && encType !== COL)) {\n      hasOtherO = true;\n    }\n    if (hasAggr && hasOtherO) break;\n  }\n\n  return hasAggr && !hasOtherO;\n};\n\n\nfunction genEncs(encs, fields, stats, opt) {\n  // generate a collection vega-lite's enc\n  var tmpEnc = {};\n\n  function assignField(i) {\n    // If all fields are assigned, save\n    if (i === fields.length) {\n      // at the minimal all chart should have x, y, geo, text or arc\n      if (generalRules(tmpEnc, stats, opt)) {\n        encs.push(vl.duplicate(tmpEnc));\n      }\n      return;\n    }\n\n    // Otherwise, assign i-th field\n    var field = fields[i];\n    for (var j in opt.encodingTypeList) {\n      var et = opt.encodingTypeList[j],\n        isDim = isDimension(field);\n\n      //TODO: support \"multiple\" assignment\n      if (!(et in tmpEnc) && // encoding not used\n        ((isDim && rules[et].dimension) || (!isDim && rules[et].measure)) &&\n        (!rules[et].rules || rules[et].rules(tmpEnc, field, stats, opt))\n      ) {\n        tmpEnc[et] = field;\n        assignField(i + 1);\n        delete tmpEnc[et];\n      }\n    }\n  }\n\n  assignField(0);\n\n  return encs;\n}\n","'use strict';\n\nvar util = require('../util');\n\nvar gen = module.exports = {\n  // data variations\n  aggregates: require('./aggregates'),\n  projections: require('./projections'),\n  // encodings / visual variatons\n  encodings: require('./encodings'),\n  encs: require('./encs'),\n  marktypes: require('./marktypes')\n};\n\ngen.charts = function(fields, opt, cfg, flat) {\n  opt = util.gen.getOpt(opt);\n  flat = flat === undefined ? {encodings: 1} : flat;\n\n  // TODO generate\n\n  // generate permutation of encoding mappings\n  var fieldSets = opt.genAggr ? gen.aggregates([], fields, opt) : [fields],\n    encs, charts, level = 0;\n\n  if (flat === true || (flat && flat.aggregate)) {\n    encs = fieldSets.reduce(function(output, fields) {\n      return gen.encs(output, fields, opt);\n    }, []);\n  } else {\n    encs = fieldSets.map(function(fields) {\n      return gen.encs([], fields, opt);\n    }, true);\n    level += 1;\n  }\n\n  if (flat === true || (flat && flat.encodings)) {\n    charts = util.nestedReduce(encs, function(output, enc) {\n      return gen.marktypes(output, enc, opt, cfg);\n    }, level, true);\n  } else {\n    charts = util.nestedMap(encs, function(enc) {\n      return gen.marktypes([], enc, opt, cfg);\n    }, level, true);\n    level += 1;\n  }\n  return charts;\n};","\"use strict\";\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension,\n  isOrdinalScale = vl.encDef.isOrdinalScale;\n\nvar vlmarktypes = module.exports = getMarktypes;\n\nvar marksRule = vlmarktypes.rule = {\n  point:  pointRule,\n  bar:    barRule,\n  line:   lineRule,\n  area:   areaRule, // area is similar to line\n  text:   textRule,\n  tick:   tickRule\n};\n\nfunction getMarktypes(enc, stats, opt) {\n  return opt.marktypeList.filter(function(markType){\n    return vlmarktypes.satisfyRules(enc, markType, stats, opt);\n  });\n}\n\nvlmarktypes.satisfyRules = function (enc, markType, stats, opt) {\n  var mark = vl.compiler.marks[markType],\n    reqs = mark.requiredEncoding,\n    support = mark.supportedEncoding;\n\n  for (var i in reqs) { // all required encodings in enc\n    if (!(reqs[i] in enc)) return false;\n  }\n\n  for (var encType in enc) { // all encodings in enc are supported\n    if (!support[encType]) return false;\n  }\n\n  return !marksRule[markType] || marksRule[markType](enc, stats, opt);\n};\n\nfunction facetRule(field, stats, opt) {\n  return vl.encDef.cardinality(field, stats) <= opt.maxCardinalityForFacets;\n}\n\nfunction facetsRule(enc, stats, opt) {\n  if(enc.row && !facetRule(enc.row, stats, opt)) return false;\n  if(enc.col && !facetRule(enc.col, stats, opt)) return false;\n  return true;\n}\n\nfunction pointRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n  if (enc.x && enc.y) {\n    // have both x & y ==> scatter plot / bubble plot\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    // For OxO\n    if (xIsDim && yIsDim) {\n      // shape doesn't work with both x, y as ordinal\n      if (enc.shape) {\n        return false;\n      }\n\n      // TODO(kanitw): check that there is quant at least ...\n      if (enc.color && isDimension(enc.color)) {\n        return false;\n      }\n    }\n\n  } else { // plot with one axis = dot plot\n    if (opt.omitDotPlot) return false;\n\n    // Dot plot should always be horizontal\n    if (opt.omitTranpose && enc.y) return false;\n\n    // dot plot shouldn't have other encoding\n    if (opt.omitDotPlotWithExtraEncoding && vl.keys(enc).length > 1) return false;\n\n    // dot plot with shape is non-sense\n    if (enc.shape) return false;\n  }\n  return true;\n}\n\nfunction tickRule(enc, stats, opt) {\n  // jshint unused:false\n  if (enc.x || enc.y) {\n    if(vl.enc.isAggregate(enc)) return false;\n\n    var xIsDim = isDimension(enc.x),\n      yIsDim = isDimension(enc.y);\n\n    return (!xIsDim && (!enc.y || isOrdinalScale(enc.y))) ||\n      (!yIsDim && (!enc.x || isOrdinalScale(enc.x)));\n  }\n  return false;\n}\n\nfunction barRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // bar requires at least x or y\n  if (!enc.x && !enc.y) return false;\n\n  if (opt.omitSizeOnBar && enc.size !== undefined) return false;\n\n  // FIXME actually check if there would be occlusion #90\n  // need to aggregate on either x or y\n  var aggEitherXorY =\n    (!enc.x || enc.x.aggregate === undefined) ^\n    (!enc.y || enc.y.aggregate === undefined);\n\n\n  if (aggEitherXorY) {\n    var eitherXorYisDimOrNull =\n      (!enc.x || isDimension(enc.x)) ^\n      (!enc.y || isDimension(enc.y));\n\n    if (eitherXorYisDimOrNull) {\n      var aggregate = enc.x.aggregate || enc.y.aggregate;\n      return !(opt.omitStackedAverage && aggregate ==='mean' && enc.color);\n    }\n  }\n\n  return false;\n}\n\nfunction lineRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  // TODO(kanitw): add omitVerticalLine as config\n\n  // FIXME truly ordinal data is fine here too.\n  // Line chart should be only horizontal\n  // and use only temporal data\n  return enc.x.type == 'T' && enc.x.timeUnit && enc.y.type == 'Q' && enc.y.aggregate;\n}\n\nfunction areaRule(enc, stats, opt) {\n  if(!facetsRule(enc, stats, opt)) return false;\n\n  if(!lineRule(enc, stats, opt)) return false;\n\n  return !(opt.omitStackedAverage && enc.y.aggregate ==='mean' && enc.color);\n}\n\nfunction textRule(enc, stats, opt) {\n  // at least must have row or col and aggregated text values\n  return (enc.row || enc.col) && enc.text && enc.text.aggregate && !enc.x && !enc.y && !enc.size &&\n    (!opt.alwaysGenerateTableAsHeatmap || !enc.color);\n}\n","'use strict';\n\nvar util = require('../util'),\n  consts = require('../consts'),\n  vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = projections;\n\n// TODO support other mode of projections generation\n// powerset, chooseK, chooseKorLess are already included in the util\n\n/**\n * fields\n * @param  {[type]} fields array of fields and query information\n * @return {[type]}        [description]\n */\nfunction projections(fields, stats, opt) {\n  opt = vl.schema.util.extend(opt||{}, consts.gen.projections);\n\n  // First categorize field, selected, fieldsToAdd, and save indices\n  var selected = [], fieldsToAdd = [], fieldSets = [],\n    hasSelectedDimension = false,\n    hasSelectedMeasure = false,\n    indices = {};\n\n  fields.forEach(function(field, index){\n    //save indices for stable sort later\n    indices[field.name] = index;\n\n    if (field.selected) {\n      selected.push(field);\n      if (isDimension(field) || field.type ==='T') { // FIXME / HACK\n        hasSelectedDimension = true;\n      } else {\n        hasSelectedMeasure = true;\n      }\n    } else if (field.selected !== false && !vl.encDef.isCount(field)) {\n      if (vl.encDef.isDimension(field) &&\n          !opt.maxCardinalityForAutoAddOrdinal &&\n          vl.encDef.cardinality(field, stats, 15) > opt.maxCardinalityForAutoAddOrdinal\n        ) {\n        return;\n      }\n      fieldsToAdd.push(field);\n    }\n  });\n\n  fieldsToAdd.sort(compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices));\n\n  var setsToAdd = util.chooseKorLess(fieldsToAdd, 1);\n\n  setsToAdd.forEach(function(setToAdd) {\n    var fieldSet = selected.concat(setToAdd);\n    if (fieldSet.length > 0) {\n      if (opt.omitDotPlot && fieldSet.length === 1) return;\n      fieldSets.push(fieldSet);\n    }\n  });\n\n  fieldSets.forEach(function(fieldSet) {\n      // always append projection's key to each projection returned, d3 style.\n    fieldSet.key = projections.key(fieldSet);\n  });\n\n  return fieldSets;\n}\n\nvar typeIsMeasureScore = {\n  N: 0,\n  O: 0,\n  T: 2,\n  Q: 3\n};\n\nfunction compareFieldsToAdd(hasSelectedDimension, hasSelectedMeasure, indices) {\n  return function(a, b){\n    // sort by type of the data\n    if (a.type !== b.type) {\n      if (!hasSelectedDimension) {\n        return typeIsMeasureScore[a.type] - typeIsMeasureScore[b.type];\n      } else { //if (!hasSelectedMeasure) {\n        return typeIsMeasureScore[b.type] - typeIsMeasureScore[a.type];\n      }\n    }\n    //make the sort stable\n    return indices[a.name] - indices[b.name];\n  };\n}\n\nprojections.key = function(projection) {\n  return projection.map(function(field) {\n    return vl.encDef.isCount(field) ? 'count' : field.name;\n  }).join(',');\n};\n\n","'use strict';\n\nvar g = global || window;\n\nrequire('vega-lite/src/globals');\n\ng.CHART_TYPES = {\n  TABLE: 'TABLE',\n  BAR: 'BAR',\n  PLOT: 'PLOT',\n  LINE: 'LINE',\n  AREA: 'AREA',\n  MAP: 'MAP',\n  HISTOGRAM: 'HISTOGRAM'\n};\n\ng.ANY_DATA_TYPES = (1 << 4) - 1;","module.exports = {\n  encoding: require('./rankEncodings')\n};\n\n\n","'use strict';\n\nrequire('../globals');\n\nvar vl = (typeof window !== \"undefined\" ? window['vl'] : typeof global !== \"undefined\" ? global['vl'] : null),\n  isDimension = vl.encDef.isDimension;\n\nmodule.exports = rankEncodings;\n\n// bad score not specified in the table above\nvar UNUSED_POSITION = 0.5;\n\nvar MARK_SCORE = {\n  line: 0.99,\n  area: 0.98,\n  bar: 0.97,\n  tick: 0.96,\n  point: 0.95,\n  circle: 0.94,\n  square: 0.94,\n  text: 0.8\n};\n\nfunction rankEncodings(encoding, stats, opt, selected) {\n  var features = [],\n    encTypes = vl.keys(encoding.encoding),\n    marktype = encoding.marktype,\n    enc = encoding.encoding;\n\n  var encodingMappingByField = vl.enc.reduce(encoding.encoding, function(o, field, encType) {\n    var key = vl.encDef.shorthand(field);\n    var mappings = o[key] = o[key] || [];\n    mappings.push({encType: encType, field: field});\n    return o;\n  }, {});\n\n  // data - encoding mapping score\n  vl.forEach(encodingMappingByField, function(mappings) {\n    var reasons = mappings.map(function(m) {\n        return m.encType + vl.shorthand.assign + vl.encDef.shorthand(m.field) +\n          ' ' + (selected && selected[m.field.name] ? '[x]' : '[ ]');\n      }),\n      scores = mappings.map(function(m) {\n        var role = vl.encDef.isDimension(m.field) ? 'dimension' : 'measure';\n\n        var score = rankEncodings.score[role](m.field, m.encType, encoding.marktype, stats, opt);\n\n        return !selected || selected[m.field.name] ? score : Math.pow(score, 0.125);\n      });\n\n    features.push({\n      reason: reasons.join(\" | \"),\n      score: Math.max.apply(null, scores)\n    });\n  });\n\n  // plot type\n  if (marktype === TEXT) {\n    // TODO\n  } else {\n    if (enc.x && enc.y) {\n      if (isDimension(enc.x) ^ isDimension(enc.y)) {\n        features.push({\n          reason: 'OxQ plot',\n          score: 0.8\n        });\n      }\n    }\n  }\n\n  // penalize not using positional only penalize for non-text\n  if (encTypes.length > 1 && marktype !== TEXT) {\n    if ((!enc.x || !enc.y) && !enc.geo && !enc.text) {\n      features.push({\n        reason: 'unused position',\n        score: UNUSED_POSITION\n      });\n    }\n  }\n\n  // mark type score\n  features.push({\n    reason: 'marktype='+marktype,\n    score: MARK_SCORE[marktype]\n  });\n\n  return {\n    score: features.reduce(function(p, f) {\n      return p * f.score;\n    }, 1),\n    features: features\n  };\n}\n\n\nvar D = {}, M = {}, BAD = 0.1, TERRIBLE = 0.01;\n\nD.minor = 0.01;\nD.pos = 1;\nD.Y_T = 0.8;\nD.facet_text = 1;\nD.facet_good = 0.675; // < color_ok, > color_bad\nD.facet_ok = 0.55;\nD.facet_bad = 0.4;\nD.color_good = 0.7;\nD.color_ok = 0.65; // > M.Size\nD.color_bad = 0.3;\nD.color_stack = 0.6;\nD.shape = 0.6;\nD.detail = 0.5;\nD.bad = BAD;\nD.terrible = TERRIBLE;\n\nM.pos = 1;\nM.size = 0.6;\nM.color = 0.5;\nM.text = 0.4;\nM.bad = BAD;\nM.terrible = TERRIBLE;\n\nrankEncodings.dimensionScore = function (field, encType, marktype, stats, opt){\n  var cardinality = vl.encDef.cardinality(field, stats);\n  switch (encType) {\n    case X:\n      if (vl.encDef.isTypes(field, [N, O]))  return D.pos - D.minor;\n      return D.pos;\n\n    case Y:\n      if (vl.encDef.isTypes(field, [N, O])) return D.pos - D.minor; //prefer ordinal on y\n      if(field.type === T) return D.Y_T; // time should not be on Y\n      return D.pos - D.minor;\n\n    case COL:\n      if (marktype === TEXT) return D.facet_text;\n      //prefer column over row due to scrolling issues\n      return cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad;\n\n    case ROW:\n      if (marktype === TEXT) return D.facet_text;\n      return (cardinality <= opt.maxGoodCardinalityForFacets ? D.facet_good :\n        cardinality <= opt.maxCardinalityForFacets ? D.facet_ok : D.facet_bad) - D.minor;\n\n    case COLOR:\n      var hasOrder = (field.bin && field.type===Q) || (field.timeUnit && field.type===T);\n\n      //FIXME add stacking option once we have control ..\n      var isStacked = marktype === 'bar' || marktype === 'area';\n\n      // true ordinal on color is currently BAD (until we have good ordinal color scale support)\n      if (hasOrder) return D.color_bad;\n\n      //stacking gets lower score\n      if (isStacked) return D.color_stack;\n\n      return cardinality <= opt.maxGoodCardinalityForColor ? D.color_good: cardinality <= opt.maxCardinalityForColor ? D.color_ok : D.color_bad;\n    case SHAPE:\n      return cardinality <= opt.maxCardinalityForShape ? D.shape : TERRIBLE;\n    case DETAIL:\n      return D.detail;\n  }\n  return TERRIBLE;\n};\n\nrankEncodings.dimensionScore.consts = D;\n\nrankEncodings.measureScore = function (field, encType, marktype, stats, opt) {\n  // jshint unused:false\n  switch (encType){\n    case X: return M.pos;\n    case Y: return M.pos;\n    case SIZE:\n      if (marktype === 'bar') return BAD; //size of bar is very bad\n      if (marktype === TEXT) return BAD;\n      if (marktype === 'line') return BAD;\n      return M.size;\n    case COLOR: return M.color;\n    case TEXT: return M.text;\n  }\n  return BAD;\n};\n\nrankEncodings.measureScore.consts = M;\n\n\nrankEncodings.score = {\n  dimension: rankEncodings.dimensionScore,\n  measure: rankEncodings.measureScore,\n};\n","\"use strict\";\n\nvar consts = require('./consts');\n\nvar util = module.exports = {\n  gen: {}\n};\n\nutil.isArray = Array.isArray || function (obj) {\n  return {}.toString.call(obj) == '[object Array]';\n};\n\nutil.json = function(s, sp) {\n  return JSON.stringify(s, null, sp);\n};\n\nutil.keys = function(obj) {\n  var k = [], x;\n  for (x in obj) k.push(x);\n  return k;\n};\n\nutil.nestedMap = function (col, f, level, filter) {\n  return level === 0 ?\n    col.map(f) :\n    col.map(function(v) {\n      var r = util.nestedMap(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nestedReduce = function (col, f, level, filter) {\n  return level === 0 ?\n    col.reduce(f, []) :\n    col.map(function(v) {\n      var r = util.nestedReduce(v, f, level - 1);\n      return filter ? r.filter(util.nonEmpty) : r;\n    });\n};\n\nutil.nonEmpty = function(grp) {\n  return !util.isArray(grp) || grp.length > 0;\n};\n\n\nutil.traverse = function (node, arr) {\n  if (node.value !== undefined) {\n    arr.push(node.value);\n  } else {\n    if (node.left) util.traverse(node.left, arr);\n    if (node.right) util.traverse(node.right, arr);\n  }\n  return arr;\n};\n\nutil.union = function (a, b) {\n  var o = {};\n  a.forEach(function(x) { o[x] = true;});\n  b.forEach(function(x) { o[x] = true;});\n  return util.keys(o);\n};\n\n\nutil.gen.getOpt = function (opt) {\n  //merge with default\n  return (opt ? util.keys(opt) : []).reduce(function(c, k) {\n    c[k] = opt[k];\n    return c;\n  }, Object.create(consts.gen.DEFAULT_OPT));\n};\n\n/**\n * powerset code from http://rosettacode.org/wiki/Power_Set#JavaScript\n *\n *   var res = powerset([1,2,3,4]);\n *\n * returns\n *\n * [[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],\n * [2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n[edit]\n*/\n\nutil.powerset = function(list) {\n  var ps = [\n    []\n  ];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = ps.length; j < len; j++) {\n      ps.push(ps[j].concat(list[i]));\n    }\n  }\n  return ps;\n};\n\nutil.chooseKorLess = function(list, k) {\n  var subset = [[]];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length <= k){\n        subset.push(sub);\n      }\n    }\n  }\n  return subset;\n};\n\nutil.chooseK = function(list, k) {\n  var subset = [[]];\n  var kArray =[];\n  for (var i = 0; i < list.length; i++) {\n    for (var j = 0, len = subset.length; j < len; j++) {\n      var sub = subset[j].concat(list[i]);\n      if(sub.length < k){\n        subset.push(sub);\n      }else if (sub.length === k){\n        kArray.push(sub);\n      }\n    }\n  }\n  return kArray;\n};\n\nutil.cross = function(a,b){\n  var x = [];\n  for(var i=0; i< a.length; i++){\n    for(var j=0;j< b.length; j++){\n      x.push(a[i].concat(b[j]));\n    }\n  }\n  return x;\n};\n\n","'use strict';\n\n// declare global constant\nvar g = global || window;\n\ng.AGGREGATE = 'aggregate';\ng.RAW = 'raw';\ng.STACKED = 'stacked';\ng.INDEX = 'index';\n\ng.X = 'x';\ng.Y = 'y';\ng.ROW = 'row';\ng.COL = 'col';\ng.SIZE = 'size';\ng.SHAPE = 'shape';\ng.COLOR = 'color';\ng.TEXT = 'text';\ng.DETAIL = 'detail';\n\ng.N = 'N';\ng.O = 'O';\ng.Q = 'Q';\ng.T = 'T';\n"],"sourceRoot":"/source/"}